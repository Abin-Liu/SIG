// Use this instead of Dae_Multi_Bot.d2j
// to catch exceptions thrown by the bot.
// Exception thrown by Diablo II or d2jsp
// cannot be caught by the bot.
/*
+----------------------------------------------+
|            Daemon Multi-MF Bot               |
|              Version:0.70 Beta               |
|          Last Updated:Mar-09-2003            |
+----------------------------------------------+

  ***************************************************************************
  *************CONFIG YOUR DAE_MULTI_SET.D2L IN LIBS DIRECTORY!!*************
  ***************************************************************************

-=Copyright=-
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

-=Author=-
  Written by IchLiebeDich and Killkeeper,SteveH6479,Shrek_III
  Thanks goes to scorpio0920,he join into this project and really done something useful and powerful!

  Suggestions and ideas please visit http://forums.d2jsp.org/index.php?s=31aff8cc596fa5d6ec8aa459731b74ba&act=ST&f=79&t=17825&

-=Thanks from Killkeeper=-
  Many thanks to Syadasti for his pathfinding library.
  And thanks to Sherpya,I use a modified pathfinding library(Sh_FindPath).
  Thanks goes to Scavenger for his TownMove Library.
  Also,thanks to BlueMind, HolyCoistus and Venom for their BMpwnIt library.
  Mmm..Thanks goto mattlant for his mlMap library,I can't believe it's true! What a library!
  Thanks to Dave for Snapchip coord.
  Thanks to froggy19 & greedwind for Nihlathak coord.
  Shrine Support library by Pachelbel
  Ini Read/Write library by Element.
  Thanks Shrek_III for his awesome RunLogger!
  Thanks scorpio0920,you give me too much support!
  Thanks IchLiebeDich,you let me know what is script!
  Thanks Shrek_III again and also SteveH6479...thanks for doing something perfect to this project!

  Thanks my friend killer-0-,he gave me the original idea(to kill the Thresh Socket)
  Of course thanks goes to njaguar and his d2jsp.AWESOME work!
  
  At last,I just want to thank all the people who gave me a hand before!
  
-=Features=-
  This is a Multiple mf bot for Sorceress and Barbarian.

  Mf At: Pindle,Eyeback,Sharptooth,Shenk,Dac Farren,Eldritch,Thresh,Snapchip,
	 Bonesaw,Frozenstein,Countess,Mephisto,Stormtree,Baal,Nihlathak,
	Creeping Feature,Tristram,Council(Travincal) and all the unique bosses.
  Merc support
  Town stash/Item IDing
  Chicken(support all enchants/auras/immunities)
  Be able to cast all the sorc's skills(base on the immunities)
  Weapon switch
  Auto healing
  Logging support
  Open the chests

  And more...

-=Note=-
  This bot works just for Sorceress and Barbarian!
  Maybe dangerous,we cannot make sure your hardcore character's safety.

  You must have:
  Waypoints to the bosses you need.
  Red portal to Pindleskin

  Or the bot cannot work correctly!

-=Files=-
  Required Libraries (this list if often incomplete ;) ):
  --+ Dae_BMpwnIt.d2l
  --+ Dae_TownMove.d2l
  --+ Dae_ShFindPath.d2l
  --+ Dae_Multi_Set.d2l
  --+ Dae_lifewatch.d2l
  --+ Dae_Town.d2l
  --+ ShrineLib.d2l
  --+ Sy_Constants.d2l
  --+ dae\sorc.d2l
  --+ dae\barbarian.d2l
  --+ dae\barb.d2l
  --+ dae\Dae_mlMap.d2l
  --+ dae\classid.d2l

  Also,a important files:
  --+ Dae_lifewatch.d2j

-=ToDo=-
  This is a development edition,i will add more methods.

-=History=-
  0.70
  -> added Mausoleum just for sorc yet
  -> fixed Townmove's bug : cannot revive merc in act 2
  -> added Enigma support
  -> now pathing is on BotOS.Pathing..
  
  0.56 RC3
  => i didn't add BotOS.Pathing because i found it is not effective and unstable... :(
  -> fixed barb and zon cannot open doors, now working perfectly with Andy
  -> added Vigor support in Town for hammerdins
  -> fixed item.description has no propties
  
  0.56 RC2+
  -> added switch to skip logging
  -> fixed roomcolldata error and this.Area error
  -> removed Fara modification, because that may cause errors.
  -> if you need scrolls in Act 2, move to Malah for healing and scrolls.
  
  0.56 internal RC2
  => finally, i'm back. I AM BACK!!!!!!
  => require d2jsp v0.39
  => you need a hammerdin to do this test. 
     your hammerdin should have Blessed Hammer and one single skill among Zeal or Charge or Fist of the Heavens
     we expect you to have Zeal as a secondary skill to defeat single or magic-immune enemy
     good luck sir!
  -> add gamelength, won't get idle whole night :p
  -> add a Hammderdin support(weak support with your 2nd attack weapon)
  -> fixed a id scroll bug in Act 2
  -> added support of Tomb Reaver, huge thanks goes to tnsharp
  -> improved some usage of .id to .gid, thanks goes to tnsharp
  -> greatly improved the script execution speed of barbarian 
  -> fixed pindle position problem (stand alone at the gate now)
  -x add walking support of low-level sorc
  -> add support of Ancient Tunnel for barb
  -> add support of CTA
  -x add support of Engima
  -> now barbarians will do explore in The Pit
  (-x means TODO with)
  
  0.55b
  -> fixed akara wall bug :S.
  -> add Ancient Tunnel for javazon,explore the The Pit for javazon!
  -> better LOS check for javazon 
  
  0.55a Final
  -> improved path algo. in Ancient Tunnel
  -> fixed Attack times bug
  -> modified Townmove's Pathfind parameter. hope to fix that sucking problem.
  -> fixed Potions bug - again,Townmove bug.... :p
  -> add explore code to The Pit for Sorceress !
  
  0.55 RC6
  -> fixed Pit support for javazon. (forgot to active it :p )
  -> added barb support for the pit
  -> fixed safe meph idle bug for sorc.
  -> modified Akara's preset coordinates. hope it works with the akara major bug.
  -> added check on shrining chest in pit lvl 2
  -> improved kill check,check normal boss first ( normal unique boss is back )
  -> fixed the mlMap bug that happens very often when lost path to destination.
  -> added Ancient Tunnel,just for sorc at present.
  -> modified the way to kill monsters. no more suck SF too much
  -> improved Left-hand support for sorc. now no delays. CRAZY FASTER!
  -> if a spell is a left-hand one,cast it on target itself. (orginal one is to cast on coordinate...deadly)
  
  0.55 RC5 (Killkeeper)
  -> add The Pit lvl 2 support for both sorceress and javazon
  
  0.55 RC4 (Killkeeper)
  -> work correctly at The Pit level 1.
  
  0.55 RC3 (Killkeeper)
  -> fixed sorc's automatic skill bug - use Thunder Storm as offensive skills
  -> improved sorc's automatic skills algo.
  -> improved javazon's automatic skills algo. now supports all skills!
  -> add The Pit Level 1 in Tamoe Highland
  -> not very sure if fixed mana pots bug :) hope so
  => Baal quest is still not a go,sorry.
  
  0.54b development edition v2 (Killkeeper)
  -> fixed Revive freezing bug,thx njag and Ghetto Cruizin'
  -> modified sorc's autoskill
  -> improved javazon's attack method
  -> improved javazon's skills
  
  0.54 development edition ( Killkeeper & Shrek_III )
  -> add mana potions shop method (=> see Dae_Multi_set.d2l)
  -> fixed path to shenk for barb
  -> added hardcore protection,all chicken,heal,mana-recharge settings are marked automaticlly
     dunno if it will be very safe for hardcore characters!!
  -> improved LOS check for barb when interact with chests
  -> removed all screenhooks
  -> dictionary is removed,that is outdated
  -> a more simple way to disable all the chests! (=> see sets["disable_all_chests_CHAR"])
  -> a very weak support for Javazon,bosses support : Pindle,Shenk,Eldritch,Countess
  -> rewrited the object/monster check code,faster and more stable
  -> defaultly,for Zon and Barb,the chests are disabled.
  -> added ScaryKilling
  -> added safe meph killing method
  -> fixed baal run,now runs correctly
  -> improved auto_skill,now returns the best 2 skills :p
  
  0.53 development edition (Killkeeper)
  => dunno if this version works stably for you. use it at your own risk.
  -> lifewatch tools now can be unloaded anytime
  -> autoskill is modified for 1.10
  -> new LOS check for a barbarian interaction with objects.
  -> improved fill-potions method,works flawlessly now
  -> fixed Townmove's getBaseStat bug
  -> Sharptooth and Thresh quest fixed
  -> fixed a initnal weapon check bug
  -> removed unknown stats for 1.10,make all methods work.
  => screenhooks will be rewritten soon,don't use them,they are outdated.
  
  0.52j Official (Killkeeper)
  => last version of 1.09d,though it's timeout
  -> fix a fill cube bug,now works correctly
  -> fix a act change crash bug
  -> increase all delay values in Townmove,works more stably
  => next version may be released after long time in the future. I'm sorry. 
 
  0.52j internal RC4 (Killkeeper)
  => version for testing,not released for official
  -> fix not stash problem
  -> fix "failed to find NPC for healing" error in act 4
  -> fix Izual quest problem
  -> fix Andariel quest waypoint bug,now works correctly
  -> fix healing pots buying bug,now if sets["use_hp_pots"]=false;,no more weird pots shopping
  -> fix antidote pots problem in Baal runs
  
  0.52j internal RC3 (Killkeeper)
  => version for testing,not released for official.
  -> fix sell back failed bug when gamble
  -> fix "failed to find 'exit'" error on quest Creeping,Izual
  -> fix stash gold doesn't work bug
  -> fix shop rate bug,now shop at Larzuk,Fara,Charsi etc correctly
  -> readd waypoint check,no more long wait
  -> add a switch to choose if you need a Telekenisis-interaction with waypoint
  
  0.52i (Killkeeper)
  -> use newest TownMove 2.03,thanks scavenger! (i will improve this Townmove in the future)
  -> fix drop antidote pots when baal runs
  => enable random boss order in Dae_Multi_Set.d2l again.
  
  0.52h (Killkeeper)
  -> with Baal runs,only drink Antidote pots after each fight(if possible)
  -> add a whisper logging,check it at output\Dae_YOURNAME_MsgLog.txt (see sets["log_whispers"])
  -> faster initialization for every game(about 1 second faster)
  => acquiescently,all cubing are closed to prevent some errors,use it at your own risk!
  => buy only one Antidote potion before killing Baal
  -> if your ping is higher than 1000,bot will cancel cubing automaticly
  
  0.52g (Killkeeper)
  -> i hope i've fixed "Line 111 Error"
  -> fix a MAJOR walk bug with opening chests!
  
  0.52f++ (Killkeeper) 
  -> fix "target has no propeties" problem and use new Missile check 
  => I found the distance to Mephisto is too short that sometimes sorc doesn't have enough time to dodge. I will fix this later. 
  => also I found a chest bug,I will slove it this weekend. 

  0.52f+ (scorpio0920) 
  -> use previous Dodge Missiles, prevent "target has no properties" problem 
  => wait for better Dodge Missiles by Killkeeper  
  -> modified Dae_Multi_Set.d2l 
  -> remove \doc\History.txt, sorry I am too lazy 
  
  0.52f (Killkeeper) 
  -> add Setting file out of date check,prevent some strange problem. 
  -> now Daemon works with .34 core,no more "troom has no propeties" problem
  -> rewrite Dodge Missiles method,hope it works
  
  0.52e+ (Killkeeper) 
  -> improve anti-crash for BmpwnIt again.(internal version) 

  0.52e (Killkeeper) 
  -> fix leg problem,now sorc can get the legs correctly 
  -> prevent a crash problem in BmpwnIt 
  -> add a LOS check before barb try to kill monsters 
  -> fix a BM_CheckSpace error,now return correct value,no more strange stash 
  => no more stupid "You use the internal mlMap,be careful!" information 

  0.52d (Shrek_III) 
  ->fixed weapon switch test (if weapon switch is disabled) 
  -> fixed escape error 
  
  0.52c (Killkeeper)
  -> fix Go portal to Act4 is not work problem
  -> add alot new Events in escape settings. :p
  -> different boss,different switch hp !
  -> fix distance for some new bosses like Creeping,Cows,Izual,Coucil
     => no more Cave Distance for them,Creeping for hall dist,and the rest for openair
  -> before interacting with a SHINY chest,you can choose if you need a weapon switch
  -> fix a bug which cause the bot won't use wells
  -> you can choose if you need to clean up entries to Icy Celler and Frozen River,for speeding up => see sets["cleanup_icy_entries"]
   
  0.52b Bugfix (Killkeeper)
  -> fix the problem that the bot won't cast portals
  -> fix the problem that the bot cannot entry with a tile
  -> fix a problem that may cause a crash when interact with an object
  -> fix a "DoCast is not defined" problem
  => sorry,that's all my fault.
  
  0.52a Andy (Killkeeper)
  -> Covert it to .33 core.
  => for nonEnglish system,the colors display incorrectly.Don't worry.
  
  0.52 Andy (Killkeeper & pabst)
  -> support Andariel now!
  -> support Creeping Feature for barb now!
  -> now error log is shown in Dae_errorlog.htm with colors! lol
  -> remove a Act check,it's useless and timeout even may cause a MAJOR problem.
  -> barb won't cast a WW on less than 5 members groups(we call monsters in a circle which its radius=5 as Groups)
  -> barb will check LOS before open a chest
  -> better interact with chests for barb.
  -> barb won't kill a enemy twice(gid check,useful for Fallen etc.)
  -> added sets["gamble_gloves"]
  -> added sets["gamble_boots"]
  -> added sets["cube_runes"] / sets["cube_runesMax"]
  -> added sets["say_overhead"]
  -> took the liberty of re-rewriting the deactivation of PreSkiller by shrek_III
  -> removed gamemsgHandler in same cut.
    
  0.51 (Shrek_III)
  -> added Moo Moo Farm support (best done with nova/fo sorc)

  0.50a (SteveH6479)
  -> added a delay before selling items (more human like)
  -> added super mana pots to belt management
  -> The bot will now pick up the pots lying in town when managing potions
  -> added sets["grab_potions_at_end"], which will pickup remaining pots in town to bring to next game
  -> Fixed Dict.htm. it actually works now
  -> Implemented a cool trick with refilling keys at a non key selling npc (credits to whoever suggested it)
  -> made stopping the preskiller after the Council run client side
  -> fixed an error where it would cast telekinesis on wirt 5 times in a row

  0.50 Izzy (Killkeeper)
  -> support Izual now(sorry,I used mlMap both for barb and sorc,a little slow)
  -> treat Dae_Preskiller.d2j as a tools,you can choose load it or not in Dae_Multi_Set.d2l now.
  -> now Last time Exp logging works!
  -> now really fix Escape !! Sorry,it's my fault,I used a wrong bit mask parser.
  => for some reasons,I have no time to slove stash/barb skill bugs,sorry
  -> Update BaseSorc.d2l & BaseBarb.d2l

  0.49+ Giovanne Elber (Shrek_III & scorpio0920)
  -> sorry this damn site won't let me in yesterday (403 error) so I wasn't able to upload the dae_multi_set.d2l, done, now!

  0.49Giovanne Elber (Shrek_III)
  -> added Council (Travincal)
  -> added the Dae_PreSkiller.d2j
     this AutoSkiller is area based and will check your preskills every 2 sec
     furthermore it will be continued to support all char-classes, at the moment
     it only supports sorc, but this is v0.1 more versions to come...
  -> sorry for version name, but Giovanne Elber, my favorite soccer star is leaving FC Bayern Munich :(

  0.48i (SteveH6479)
  -> fixed that EVIL error where it doesn't pick rejuves when belt is empty!!!!
  -> sets["snag_stash_maxtimes"] actually works now

  0.48h (Killkeeper)
  -> fixed a major error - don't escape! now it works
  -> add sets["unique_before_creeping"]

  0.48g (SteveH6479)
  -> Rewrote the exchange potions code. It now works flawlessly. No more need to check for enough space while exchanging potions.
  -> slightly increased the sell item delay (more humanlike and more realistic)
  -> fixed errors that made the sorc cast telekinesis on chests/shrines/wells twice.
  -> default value for sets["use_internal_bmpwnit"] changed to false
  -> fixed gototristram not defined error (thx to aqui)
  -> default values for tristram and creeping feature changed to false (was causing barb problems)

  0.48f (Shrek_III)
  -> support for Creeping feature (Act 2)

  0.48e (Killkeeper)
  -> better Baal runs for barb
  -> better Shenk runs for barb
  -> new format for esc_xxx (new format is very powerful,but hard to use,be careful! I used bit mask)
  -> fix sets["kill_special"],now works right! :eyes:
  -> faster Girswold mapbuild
  -> larger kill range in Tristram

  0.48d (Shrek_III)
  -> added Griswold and his friends in Tristram + Rakanishu

  0.48c (Killkeeper)
  -> add gamename dictionary support!
  -> fix a unchicken problem when errors happen
  => to create a random dictionary,please use settings\Dict.htm!
  => to modify your dictionary,please open your settings\gamedict.ini by a Ascii Editor!

  0.48b (Killkeeper)
  -> fix a problem that cause bot don't pick up items after return to town
  -> if you don't use Antidote pots,the bot won't buy it too.
  -> better Countess code
  -> fix a gamble problem.

  0.48 (Killkeeper)
  -> now modify some chicken settings,for safety,chicken mana is enabled again (10% is default value).
  -> if place in inventory is less than an appointed col width,return in town => sets["town_min_col_inventory"]
  -> if return in town,first find a safe place
  -> enable return in town method for mlMap pathfinding
  -> Wow! Back to ShFindpath again! Remember 0.46e? High speed and better runs !

  0.47k+ (Killkeeper)
  -> now belt manage works flawlessly,fix some manage errors,more clever!
  => everyone plz modify your Dae_Multi_Set.d2l,plz use sets["use_internal_bmpwnit"]=true; !
     I found a bug in new BMpwnIt r1.65

  0.47k (Killkeeper)
  -> better barbarian pathfinding paramter
  -> fix a preskill problem for barbarian
  -> better interact with chests for barbarian
  -> much better potions manage code by Shrek_III,thanks Shrek_III for his excellent work!
  -> auto release your memory so that run faster
  -> now your magic find % is a correct value
  -> rewrite "if your inventory is full,before snag item,stash first." method by offical BMpwnIt r1.65
  => to use stash when SnagIt,remember to enable sets["snag_stash"]!
  -> faster Countess code for sorceress
  -> add Last Experience logging
  => 0.47i is a internal version.

  0.47h (Killkeeper & scorpio0920)
  -> fix a "checkmissile is not defined problem for Barbarian.
  -> update Bmitems.ini/snagit.ini/BmShopit.ini for Daemon Multi-MF Bot

  0.47g (Killkeeper)
  -> fix a [forwardheuristics[_fh]] is not a function problem(I think)
  -> add some logging (worst time,last time kill time etc.)

  0.47f (Killkeeper)
  -> fix sets["random_quest_count"]
  -> modify some pathfinding parameter(I'm trying to find a best parameter :p)

  0.47e (Killkeeper)
  -> better random boss method
  -> modify pathfinding parameter as mattlant suggested
  -> fix preskill problem
  -> fix escape for Lister The Tormentor
  -> default value for Eyeback is 'false'

  0.47d final (Killkeeper)
  -> fix a cube problem(may mistake recipes)
  -> better dodge missiles for Mephisto
  -> fix some other minor problems.

  0.47d(debug 12) (Killkeeper)
  -> fix a problem that cause weapon switch back when back to town.
  -> add dodge missiles for Mephisto (alpha version,still in test)
  -> fix if wrong skills defined and no correct skills,the bot won't cast skills.
  -> chests dists are base on your area => see Dae_Multi_set.d2l
  -> even more safer Nihlathak mode (still in test)

  0.47d(debug 9) (Killkeeper)
  -> modify some order code for Nihlathak

  0.47d(debug 8) (Killkeeper)
  -> you can make some bosses be executed every run => see sets["always_execute"] (just in test)
  -> if Nihlathak safe mode if enabled,Nihlathak will be the first boss.
  -> modify some code in autoskills for sets["enable_all_skills"]
  -> fix some chicken logging

  0.47d(debug 7) (Killkeeper)
  -> modify some parameter for pathfinding
  -> if your inventory is full,before snag item,stash first. (YOU MUST set sets["use_internal_bmpwnit"]=true; !!)
  -> fix a gamble problem => after gamble,may fail Pindle and Nihlathak
  -> fix a "Tile has no properties" problem.
  -> fix some little barb pathfinding bugs.(keep casting skills)
  -> fix a problem that may fail pathfinding to Baal.(reactivte mlMap for Baal,sorry)
  -> prevent some problem happen.
  -> add escape setting for Lister The Tormentor
  -> fix a deadlock loading perso file error.
  => some users reported me they have a cube problem,so plz modify sets["cube"] to false;

  0.47c (Killkeeper)
  -> no matter last time you died or not,drop your Antidote/Stamina/Thawing potions
  -> add a waypoint mode for pindle
  -> fix some pathfinding problem(i found some code in mlMap cause these problem,so i use internal mlMap)
  -> modify some parameter for eyeback

  0.47b (Killkeeper)
  -> toss out your Antidote/Stamina/Thawing pot when game start (thanks scorpio0920)
  -> if you don't define skill and sets["auto_preskill"]=false; won't cast preskills (thanks kissmekissu,dreamon84,pott296)
  -> fix a problem that cause bot don't cast Static Field
  -> before Dac Farren,kill Shenk (it's a switch)
  -> fix a problem that may cause cast Thunder Storm under safe Nihlathak mode!
  -> thanks Shrek_III for his excellent Daemon Runlogger!
  => thanks all people who appointed the bugs! Really thanks!

  0.47a (Killkeeper)
  -> fix some problems in preskills

  0.47 (Killkeeper)
  -> add a safe Nihlathak mode => see sets["safe_nitlathak_code"] in Dae_Multi_Set.d2l
  -> fix a KillMinions problem(use the skill of the bosses,low efficiency)
  -> before pathfinding in Halls of Vaught,kill minions around me
  -> use Well when you life/mana is not full
  -> add a "Anti-Idle" tools => see Dae_Multi_Set.d2l
  -> add a "random quest" switch => see Dae_Multi_Set.d2l
  -> if the last boss is Mephisto,go though the red portal to Act4 (it's a switch)
  -> fix a bug that cause barb pathfinding to Countess failed.(it's my fault,use the same code as sorc) :-(
  -> fix a bug that if barb is circled with monsters,failed pathfinding.
  -> prevent some errors happen(pathfinding error,waypoint etc.)
  -> readd Kill Normal Bosses on the way to Eyeback
  -> check your waypoints before kill bosses => save time
  -> before you kill Baal,buy Antidote potion
  -> when you're poison,frozen or even low stamnia,auto drink your potions(Antidote,Thawing,Stamina)
  -> add if none boss is enabled,try to kill a random boss(it's switch) => See Dae_Multi_set.d2l
  -> modify the way to use preskills => see Dae_Multi_Set.d2l
  -> reactivate ShFindPath for Dac Farren,Thresh,Mephisto,Baal => much faster speed!
  -> add a delay setting after taking waypoints
  -> add Hephasto The Armorer(may be very dangerous for your sorc!).
  -> add cube Small/Large/Grand Charms,Colossus Blade/Sword,Matriarchal/Matron Bow,Jewels and custom stuff => see Dae_Multi_set.d2l
  -> collect cube recipes
  -> when your stash is full,fill your cube(it's a switch)
  -> add gamble circlet/amulet/ring
  => a small suggestion => minimize you Diablo window,don't watch it,to save CPU power and memory!

  0.46Evil (Killkeeper)
  -> fix a problem that may fail pathfinding to Mephisto

  0.46Elf (Killkeeper)
  => I really hope this is the last release for version 0.46 =)
  -> higher efficiency for barb pathfinding
  -> add Dac Farren,Snapchip,Stormtree for barb,now barb can mf the same bosses as a sorc!
  => Dac Farren part works like Bloody Run :p,but don't kill all.
  -> add a life/mana check during sorc pathfinding.

  0.46Ex (Killkeeper)
  -> add Eyeback,Sharptooth,Shenk,Countess for barb,:p
  -> modify the way for barb to pathfinding.
  -> fix a "currentmap.FindPathToRoom is not a function" problem
  -> higher efficiency for sorc pathfinding

  0.46z+ (Killkeeper)
  -> fix the "CheckCollision is not defined" problem.

  0.46z (Killkeeper)
  -> cancel amazon part
  -> replace almost all pathfinding code by mlMap
  -> add shoptimes and cubetimes logging
  -> modify the way to interact with the waypoint,support Non-Battle.net server well
  -> use the newest mlMap pathfinding library
  -> modify much code to make the bot run with less crash(i hope)
  -> add a money check before you buy anything

  0.46e+ and 0.46f (Killkeeper) (this version and even higher require 0.32 core!)
  -> upload 0.32 core files.

  0.46e (Killkeeper)
  -> fix a deadlock include personal setting file problem.

  0.46d (IchLiebeDich)
  -> barb cries are now based on time (like autoskill) (4 news sets["min_left_time_xxx"])
  -> barb : better dist to stop before frozenstein
  -> barb : better code to open chest
  -> correct a bug that prevent drinking anti-cold potion
  -> correct the chest safe code
     now sets["skip_uniquetype"] is really to skip chest and not the inverse lol
     name conflict with CheckIsWrongType
	 ...
  -> add vec_coord.d2l because this causes some problems
  -> correct a problem with thresh (the bot try to kill monster on him, this can be very bad if thresh is pi)
  -> correct problem with trying to kill phantom monster in baal.

  0.46c (Killkeeper)
  -> try not to open a chest when there're skipped-type-monsters.
     (for example,if there're Undead Stygian Doll around the chests,skip it.)

  0.46b (IchLiebeDich)
  -> desactivate the d2hackit wp method by defaut (see sets["wp_d2hackit"] )
  -> correct sets["revive_after_fight"] , only 1 return to town, only return if merc is death ;) (works too for barb)
  -> reintroduce sets["min_dist"] because sets["times_xxx"] is not working (bug fixe, no time to improve that)
  -> reactivate the exit of game in case of error

  0.46a (Killkeeper)
  -> add Waypoint code for Non-Battle.net Server.
  *** If you want to use this method,copy your D2HackIt.dll,D2HackIt(_New).ini to your DIABLO DIRECTORY\Plugin\ folder(you have to install Onlyer's D2Loader)
  *** Clean up the Autoload setting in D2HackIt(_New).ini
  *** Of course,if you use SIG(Stay in Game) GUI,you don't need to do the 2 steps above!
  *** (Stay In Game) is a general GUI program by Abin from China,so its language is Chinese.

  -> try to revive your dead merc after killing each group of Throne enemies
  -> modify the format of sets["times_xxx"] see Dae_Multi_Set.d2l (thanks scripio)

  0.46 (IchLiebeDich)
  -> update to support BMpwnIt 1.62 (override BM_TeleItem, more safe, name collision with DoDel)
  -> use a internal shop function (check inventory before shopping, more lag tolerant)
  -> change the limit to SF in function with difficulty
  -> add sets["precast_fire"] to launch meteor/hydre/FW before static field
  -> reduce the "chance" to use FireBall on LEB
  -> Check life when waiting with function DoDel
  -> if life < 20% or mana < 20% => try to use full reju before small
  -> silent mode for lifewatch
  -> add sets["always_stash_existing"] (very useless, only for nb vexxan)
  -> add Nihlathak
  -> better support sets["phys_whirlwind_first"] :
       kill all minions before the boss (before it stops at 3)
	   use the skill you have defined and not WW
  -> add sets["barb_kill_minion_first"]
  -> correct a bug to find the closest ennemy in baal throne
  -> now in the baal quest, if merc is poisoned => return in town
  -> in the baal quest, if the barb return in town, it can stash too.

  0.45g (Killkeeper)
  -> ask for heal when your merc is cursed/frozen/poison

  0.45f (IchLiebeDich)
  -> Correct problem if merc is ressurected => not under lifewatch
  -> Internal BMpwnIt (problem with 1.612 that are bugged)
  -> add sets["shop_rate_act1"], the purpose is to disable always shop in act1 (problem with elite)
  -> add sets["finish_in_town"], the purpose is to chain with bot with no stashing...
  -> rewrite code to shop at anya
  -> now if you use mana_recharge, it tries to drink mana potion (Thx to Durante)
  -> can use potion in inventory (Durante)
  -> Implement a back in town if you have no potion left (check sets["town_hp_no_pots"] & sets["town_mp_no_pots"]) while in battle

  0.45e (Killkeeper)
  -> more flexible shopping than always shop
  -> add shop at anya

  0.45c (IchLiebeDich)
  -> correct a bug that prevent shop to work correctly (thx to provoko)
  (be aware that BMpwnIt 1.612 is bugged too, on line 580 change item in shopitem)
  (actually to do shopping you need BMpwnIt 1.611 and Dae 0.45c)

  0.45b (IchLiebeDich)
  -> Add baal for sorc (disabled by default, be carefull do not forget 5 boss before + blood mana + magic maiden, +lvl 2 with bad minions)
  -> publish sets["chest_with_monster"] (evil urne)
  -> workaround a small bug with loop in return to town in baal quest (problem with belt empty but with reju in 1st line)

  0.45 (IchLiebeDich)
  -> Correct a bug in GetKey (this explains the pause between movements)
  -> Check version of constants
  -> Now can buy keys in act 3
  -> Update for the barb only :
	- Add baal for barb (very alpha and very hard :D )
	- Modified movement to reach the boss

  0.44c (Killkeeper)
  -> improved Dae_EleIniLib.d2l => it support new Boss Ini Read/Write better. not need to modify LogLoad() & LogSave() any longer

  0.44b (IchLiebeDich)
  -> found the crash bug in TownMove (=> now i have tested this version, 15 hours without any crash)

  0.44 (IchLiebeDich)
  -> Do not open barrel anymore
  -> Better WP code
  -> Reduce the crash game frequencies
  -> Update to Sy_Constants 0.5
  -> Update for the barb only :
  	- Only switch on boss
    - Add weapon switch (sets["BarbChangeWeaponPre"]) before to cry
    - Do not switch with berserk attack
    - Better movement
    - Try to escape Bremm Sparkfist
	- Better check to escape bad boss on the way
	- Open chest on the way
	- Pindle

  0.43a (Killkeeper)
  -> correct frozen check (use getState(11) but not getState(1))

  0.43 (IchLiebeDich)
  -> Support autoskills (sorc)
  -> Can send a pre cold spell at the beginning of the battle
  -> Modified the usage of SF (static field) (if the resist of boss < 50% =>
      send only SF before any other skills)
  -> Support BMpwnIt 1.611 => you can change the file used for shopping (sets["shop_ini"])

  0.42c (Killkeeper)
  -> add immune check function => no need afraid of fogetting to modify immune escape setting after you change your skill.
  -> use new format for logging temp file(i don't use Ele_WriteIniLine because it's too slow!)
  -> do barb weapon switching

  0.42b (IchLiebeDich)
  -> Modified TownMove to correct 3 problems : delay with TP, shopping at Ashera, buying pots
  -> Modified the code to identify chest & shrine
  -> better path for barb for meph & thresh (i hope)

  0.42a (IchLiebeDich)
  -> correct a stupid bug in barb meph
  -> more natural approch to cube

  0.42 (IchLiebeDich)
  -> add meph & thresh for barb
  -> correct path finding for sorc
  -> correct shopping with BMpwnIt 0.61
  -> correct transmute gems

  0.41a (Killkeeper)
  -> add cube perfect gems

  0.41 (IchLiebeDich)
  -> better check for shrine support
  -> open chests and others (on hop, not on every teleport) + open chest behind meph
  -> desactivate dodge missile for meph (this cause problem with name collission)
  -> check conviction before attack meph
  -> redisplay quest even if low_cpu if on

  0.40b (IchLiebeDich)
  -> now use the "official" BMpwnIt library (no branching anymore).
  -> correct a problem when shenk is killed after eyeback
  -> correct problem with random boss and all boss are not activated (=> error boss has no properties)

  0.40a (IchLiebeDich)
  -> correct some bug introduced in 0.40.

  0.40 (Killkeeper)
  -> add mephisto(taken from The Multi-MF Bot),stormtree support.

  0.39 (IchLiebeDich)
  -> add the countess  (by default, countess is disabled, check that you have the wp and enable it.)

  0.38d (IchLiebeDich)
  -> Update to version 1.60 of BMpwnit, now it is the same version,
     be carefull of eval-id & eval-pu, i think that it is not needed anymore
     to support the old version, the new synthax with skillxxx & eval-pro can
	 do all.
  -> buy of a tome of tp if needed
  -> remove item logging

  0.38b && 0.38c (Killkeeper)
  -> removed sets["kill_ghostly"] & sets["kill_champion"] but use sets["kill_special"](see Dae_Multi_set.d2l)
  -> add a whirlwind attack when phys immune
  -> check each quest(if one boss is never killed and the bot cannot find the boss for over 5 times.skip this boss.)
     see sets["check_quest"]
  -> add sets["show_debug_information"],no need to modify it =)

  0.38 (IchLiebeDich)
  -> Added support for final damage levels (Ven0m)  maxdmg, mindmg, avgdmg (in ini files)
  -> add more check on usable skill (can not cast a skill that you do not have)
  -> reduce delay for check casting from 50 => 20 (1/2 frame)
  -> correct a useless warning when selling armor item
  -> add mingoldpickup

  0.37e (IchLiebeDich)
  -> correct a small bug in find item
  -> problem with screenhook and quest display

  0.37d (IchLiebeDich)
  -> correct bug (MaxAttack not defined, problem with no random boss).
  -> add checks on find item for barb
  -> new pos attack code for sorc (take care of wall and other nearest monsters)
  -> use a flag in place of a manual time for timered spell

  0.37c (Killkeeper)
  -> if frozen,go to buy a Thawing pot and drink it.

  0.37b (Killkeeper)
  -> you can set the order to kill bosses.

  0.37a (Killkeeper)
  -> fix some pathfinding error in random boss system
  -> may fix a deadlock killing error
  -> add mana recharge max time

  0.37 (Killkeeper)
  -> add randomly kill boss system

  0.36b (Killkeeper)
  -> add mana recharge after killing each boss

  0.36 (IchLiebeDich)
  -> little support of barbarian (alpha stage support eldritch, bonesaw, frozenstein),
	need a barb with ww, berserk & leap attack (=> it can use find item with switch on boss (it is automatic))
	all attack code come from Multi MF scavenger bot
	the bot heavily uses matlant pathfindind, thus you need a good CPU.
  -> better support of multiple perso support
	(can include file libs/Dae/Perso/personame.d2l to override Dae_Multi_Set)
  -> add a specific snagit delay for shenk (sets["snag_delayshenk"])
  -> add the range of snagit (sets["snag_rad"]) => usefull for multi perso support
  -> change the location of some files, split perso specific code in sorc.d2l, barb.d2l
  -> modified BMPwnit.d2l to speed pickup for barb

  0.35f (Killkeeper)
  -> Added Items logging in your Dae_CHARACTERNAME_Log.txt
     You can find it in "Items" part.

  0.35e (IchLiebeDich)
  -> Shrine lib modified

  0.35d (IchLiebeDich)
  -> correct a crash if inventory is full

  0.35c (IchLiebeDich)
  -> correct a problem in GotoUniqueBoss in boss is too near
  -> correct html logging (thx to eosphoros)
  -> correct a problem if only hp position when you reach the lvl reju with no reju (thx to eosphoros)
  -> now check for normal unique work after killing a super unique
  -> small modification to switching (more check)

  0.35b (IchLiebeDich)
  -> more check on repathing after unique
  -> correct the length of the path returned by Sh_FindPath (=> i think it was the source of all problem)
  -> stop repathing for eye => because it is not on the same area !!
  -> add sets["healifcursed"]
  -> add sets["check_unique_every_hop"] (seems depend the power of CPU)

  0.35a (Killkeeper)
  => modified some bugs in killing unique bosses.
  they are:
    -> long distance check(100),modified to 50
    -> acquiescently,doesn't kill Champion and Ghostly monsters
    -> in pathfinding,each two steps,check the normal bosses once.

  0.35 (IchLiebeDich & Killkeeper )
  => kill unique boss on the way

  0.34b (IchLiebeDich)
  -> caching of ini files
  => do some correction to the library BMPpwnIt (snagit) to support the usage of
     eval-id & eval-pu. Be carefull to not use NOT_IDENTIFIED
     in eval-pu, because if some reason, after IDing, something bad happens (crash,
     full stash, ...) => on the next eval, the item will be dropped (it is not
     so bad for magic for example when full stash but i write this remark
     to remember this subtlety for everyone ;) ). The main reason to this work is :
     eval-id=CHARGED_SKILL_1_SKILL == TELEPORT :D
  -> try to escape the problem of error message with phantom item after selling
  -> log as before to see dropped item after ID
  -> stash directly if something was buyed now
  -> sell keys if inventory full for IDing (buy back after ;) )

  0.34 (IchLiebeDich)
  => can kill minions
  => add stat for the best time
  -> change the parameters of killboss function (bpos => mindist)
  -> use the shenk's skill to kill minions (before it uses global skills)
  => rewrite the item management (now can sell, can use book of identity, identify at the NPC)
  -> change in Docastxxx (if item on cursor => try to drop it in place of quit)
  => if script error => go out
  => add shrine support

  0.33a (IchLiebeDich)
  -> forgot stats for frozenstein :D

  0.33 (IchLiebeDich)
  -> add a snagdelay (sets["snag_delay"]) (in 0.32b, this delay was horrible (to 4-5 sec !!))
  -> delete Dae_BuildOpenMap because it is the same as SC-ShFindPath
  -> gotosharp & gotodac modified
  -> correct infinite loop when buying key or ID scroll (for example if no room)
  => add Frozenstein (at your risk :D )

  0.32b (IchLiebeDich)
  -> fix delay in GotoPindle
  -> fix path from wp for GotoDac
  -> If you do not want keys, it heals always => corrected
  -> If chest is locked and you have no keys => it does not try to open and snag ;)
  -> no need to walk with locked chest => tele works too :D
  -> As not mentionned in 0.32, the order of log is modified, it is better to delete your old stat.
  -> retry to open chest
  -> add sets["min_dist"] to be more agressive
  -> when picking, change the delay(2000) to call CheckMe() => safer ;)
  -> correct message with last tome

  0.32 (Killkeeper)
  => add Dac Farren
  => fix some minor bugs about stash

  0.31b (Killkeeper)
  => can open a locked chest now.
  => fix sets["tpafterpindle"],now it works correctly.

  0.31a (Killkeeper)
  => just fix one bug: still do weapon switch if sets["weapon_switch"]=false;

  0.31 (IchLiebeDich)
  => open chest (with Telekinesis), of course work only on non-locked chest
  => better algoritm to check position with attack
  => not use skill on boss that is immune to this skill
  => special KillShenk function to be more safe
  -> do not use SF if hp < 50% or lightining immune :D
  -> add a comment line of to disable SF in Dae_Multi_set
  -> forget to switch after killing champion => now, no switching at all for champion
  -> option to begin to kill minion of shenk before (more safe i think)
  -> now we can override the kill function for a boss ( listboss[i].killfunc )
     it is great for a particular case

  0.30a (internal version, not realse)
  => make some adjustment to doWeaponSwitch to be better
  => add exp to log
  => display in the log : total running time and time in town

  0.30 (IchLiebeDich)
  => Added Bonesaw Breaker

  0.29
  -> We forgot to implement function Abort :D
  => improved switching weapons (for all boss)
  -> now, the bot try to take the good switch at startup
  => greatly improve the attack
     now can use untimered spell while timered spell
     no useless delay (=> can be dangerous and can not switch while this time )
  -> add a cast_rate for future use in attack function
  -> move function checklife to Dae_Attack
  -> now we use the same function to kill champion (snapchip) as boss
  -> does not pickit if no champion killed (snapchip)
  -> modified checklife because when boss is death it is useless !!

  0.28
  => Added PindleSkin
  => Change ShPathFind to SC_ShPathFind, same code but no quit function in it !!
  => Only 1 attack functions now
  => Correct Dae_lifewatch as described in 0.25 (reju for merc)

  0.27
  => Added SnapChip (kill champion before)
  => Fixe an infinite loop in walkto && Teleport :(
  -> Change the method InTown (because difficult with multiple boss)
  => modify checkenchant to add an esc_global => checkenchant2
  -> Add CheckMe in teleport :eyes:
  -> Fixed the problem that i is a global variable and houlala !!
  -> Try to centralise code to attack (only 1 code for all boss except shenk and eldritch)
  => Change logging (average time by boss, chicken, misses boss)
  => Rewrite the ShFindingPath for thresh
  => Add the ability to chain with another script (experimental)
  => If cursed or poisoned in town => healing
  => now support use_screenhook = false
  -> Delete the variable position
  => better pathing
  -> modify functions used for pathing ( Sh_FollowPathToThing2 & TeleportToStairs )
     the strange function TeleportToward is disabled
  -> corrected the lifewatch in multithread mode
  -> reduce TeleportDeadlock to reduce the lost in time

  0.26
  -> Added mlMap pathfinding to Thresh! Wow! Get excited!

  0.25
  -> Added CheckErrors (from scavenger) because there is somewhere errors and i will become crazy !!
  -> Correct some default value in Dae_lifewatch
  -> add a rejuthresh for merc too (change the goal of sets["merc_pot"])
  -> add monothread feature (do not launch load('Dae_lifewatch') but include)
  because i have a lot of issue of null print with the core 0.30 with 2 running scripts
  (for the moment, i only use this new monothread feature, and wha => very stable now (try for 4 hours and no exceptions) )
  -> Fixe an infinite loop in TeleportToStairs if invalid coord.
  -> correct a bug sets["repair_pecent"] => sets["repair_percent"] => never repair ;)
  -> do not try to give a reju to merc if no healing potion and sets["merc_reju"] is not 0
  -> added shopping
  -> tresh reactivated but it miss often :(
  -> problem with thresh come from Sh_BuildOpenMap => quit if no room finded !!
  -> include a new Dae_Tools.d2l to have display on the screen but with low CPU (and only 1 thread)

  0.24
  -> Correct problem with .cancel and .getNext
  -> Stupid error of case sensitive => can not revive merc

  0.23 (this version and even higher Require 0.31 core)
  -> Can ID item
  -> use more townmove function (stash)
  -> Can buy and use life potions
  -> Modified Sh_FollowPathToThing2 to use Teleport

  0.21 Beta (this version and lower Require 0.28 core):
  -> make you bot manage your private stash,wow~
  -> toss out useless items.
  -> add a autodrink tools,better pot drinker!
  -> fix a lot of minor bugs to make this bot run better. =)

  0.2d Alpha:
  -> fix a problem that the bot never repair~ =(
  -> fix a problem that The bot will never switch weapons (I forgot to add this)
  -> add screenhook for 640x480 video mode.
  -> display each boss' aura/enchant/immunity before killing them

  0.2c Alpha:
  -> move to boss's corpse before use SnagIt to pick up the items.
  -> use Frozen Orbs to clean up the bosses' underlings. (maybe just freeze them =) )
  -> fix Line 468 ERROR : DeltaTeleport......
  -> fix Logging NaN Error

  0.2b Alpha:
  -> fix Some minor bugs about logging.
  -> fix some HUGE bugs about pathfinding to Sharptooth(miss the boss).
  -> modify the bot's position to the bosses => higher.
  -> DoDel will delay a shoter time than before(use delay ping/2-50)

  0.2a Alpha:
  -> fix some minor bugs about drinking pots.

  0.2 Alpha:
  -> add mlMap pathfinding to each boss.
  -> add a screenhook : Information displays on screen
  -> add enchants support.
  -> clean up useless code.

  0.1a DEMO:
  -> fix some minor bugs(pathfinding to Thresh).

  0.1 DEMO:
  -> First release.

*/

//*********************************
//*           settings            *
//*********************************
var CURRENT_VERSION = "0.70 Beta";
bprint( "Daemon Multi-MF Bot ÿc4" + CURRENT_VERSION + " ÿc@by ÿc2IchLiebeDich,Shrek_III,SteveH6479,Killkeeper,scorpio0920");

var Loading=getScreenHook();
Loading.text=".: Initializing...Please wait... :.";
Loading.color=2;
Loading.font=2;
Loading.x=160;
Loading.y=280;


//bprint("Initializing Daemon Multi-MF Bot...");

//Move to libs/Dae_Multi_Set.d2l!
var REQUIRED_SETTING_VERSION=0.563;
var Dae_debug_file = "output\\dae_debug.txt";
var Dae_error_log = "output\\Dae_ErrorLog.htm";

var right_hand = 0;
var left_hand = 1;

// ****************************
// *       Program Part       *
// ****************************

//WARNING:DON'T EDIT THE COMMAND LINES BELOW EXCPET YOU KNOW WHAT YOU'RE DOING!

var need_id_scrolls=0; //xx
var need_key=0;
var needkey=0;
var sthShopped = false;
var tome_count=0;
var included=false;

var randomline=new Array();

//Weapon Switch
var wea_switch=false;

// time meseasure
var timelost = 0;
var xponunique = 0;
var begingame;

var killedboss=new Array();

//Shook
var sl;
var ss;

//Died?
var died=false;

//backtown
var backtown=0;

//frozen?
var frozen;

//Enchant
var strenchant=null;
var straura=null;
var strimm=null;

//Npc Shopped?
var anyashopped=false;

//Paths
var shenk_path = new Array(7);
shenk_path[0] = new Array(3793,5102);
shenk_path[1] = new Array(3818,5105);
shenk_path[2] = new Array(3834,5114);
shenk_path[3] = new Array(3854,5124);
shenk_path[4] = new Array(3863,5126);
shenk_path[5] = new Array(3876,5115);
shenk_path[6] = new Array(3892,5115);

var eld_path = new Array(7);
//back to waypoint
eld_path[0] = new Array(3876,5112);
eld_path[1] = new Array(3858,5117);
eld_path[2] = new Array(3831,5111);
eld_path[3] = new Array(3804,5104);
eld_path[4] = new Array(3781,5105);
//go to eld
eld_path[5] = new Array(3759,5090);
eld_path[6] = new Array(3743,5077);

//pindle
var pindle_path = new Array();
pindle_path[0] = new Array(10063,13276);
pindle_path[1] = new Array(10059,13234);

//special monster bonus list:
var speclist=new Array();
speclist.push("Champion");
speclist.push("Ghostly");
speclist.push("Fanatic");
speclist.push("Berserker");
speclist.push("Possessed");

//Logging
var nlog=14; //v0.27
var nlogDisplayed = 5;
var log = new Object();
log["inifile"] = "output/Dae_" + me.name + "_Log.txt"; //log file
log["Total"]=0;	//total
log["Success"]=0;	//success
log["Died"]=0;	//died
log["Chicken"]=0;	//chicken
log["Merc_Chicken"]=0;	//merc_chicken
log["Ping"]=0;	//ping
log["Finish"]=0;	//number of finished game (with fail eventually)
log["TotalTime"]=0;	//total time
log["TimeInTown"]=0;   //time in town
log["ShopTimes"]=0;
log["CubeTimes"]=0;
log["DictNumber"]=0;
log["GameName"]="";
var logname=new Array("inifile","Total","Success","Died","Chicken","Merc_Chicken","Ping","Finish","TotalTime","TimeInTown","ShopTimes","CubeTimes","DictNumber","GameName");


// All are initialised in Initlistboss
var nlistboss = 26;
var listboss = new Array(nlistboss);
var bossshenk;
var bosseld;
var bossthresh;
var bosssharp;
var bosseye;
var bosssnap;
var bosspindle;
var bossbone;
var bossdac;
var bossfroz;
var bossbaal;
var bossnihlathak;
var bosshephasto;
var bosstristram;
var bosscreeping;
var bosscouncil;
var bossizual;
var bosscows;
var bossandy;
var bosspit;
var bossancient;
var bossmausoleum;
var bossunique;
var nPindle=0;
var nEyeback=1;
var nSharptooth=2;
var nShenk=3;
var nDacFarren=4;
var nEldritch=5;
var nThresh=6;
var nSnapchip=7;
var nBonesaw=8;
var nFrozenstein=9;
var nCountess=10;
var nMephisto=11;
var nStormtree=12;
var nBaal=13;
var nNihlathak=14;
var nHephasto=15;
var ntristram=16;
var ncreeping=17;
var ncouncil=18;
var nIzual=19;
var nCows=20;
var nAndy=21;

//Thresh Socket positions
var line=new Array();

include ("Dae_monster.d2l");
include ("Dae_TownMove.d2l");

//Include

if ( typeof( c_Sy_Constants_Version ) == "undefined" )
    include ("Sy_Constants.d2l"); // include need for constant in Dae_Multi_Set

LoadSettings();


sets["shopitfile"]=sets["shop_ini"];

if ( sets["use_internal_bmpwnit"] )
	include ("Dae_BMpwnIt.d2l");
else
	include ("BMpwnIt.d2l");

//Pathfinding libraries
include ("Dae_ShFindPath.d2l");
include ("dae/Dae_mlMap.d2l");
include ("Dae_Attack.d2l");
include( "Dae_Town.d2l" );
include( "Dae_Objects.d2l" );
include( "Dae_EleIniLib.d2l" );
include( "common/d2jsp-pathing.d2l");

switch(me.classid)
{
	case 4:
		include("dae/barb.d2l");
		break;
	case 1:
		include("dae/sorc.d2l");
		break;
	case 0:
		include("dae/javazon.d2l");
		break;
	case 3:
		include("dae/hammerdin.d2l");
}


//Immune/Aura/Enchant
var imm = new Array(7);
imm[1]=new Array(36,"Immune to Physical");
imm[2]=new Array(37,"Immune to Magic");
imm[3]=new Array(39,"Immune to Fire");
imm[4]=new Array(41,"Immune to Lightning");
imm[5]=new Array(43,"Immune to Cold");
imm[6]=new Array(45,"Immune to Poison");

var enc = new Array(13);
enc[1]=new Array(5,"Extra Strong");
enc[2]=new Array(6,"Extra Fast");
enc[3]=new Array(7,"Cursed");
enc[4]=new Array(8,"Magic Resistant");
enc[5]=new Array(9,"Fire Enchanted");
enc[6]=new Array(17,"Lightning Enchanted");
enc[7]=new Array(18,"Cold Enchanted");
enc[8]=new Array(25,"Mana Burn");
enc[9]=new Array(26,"Teleportation");
enc[10]=new Array(27,"Spectral Hit");
enc[11]=new Array(28,"Stone Skin");
enc[12]=new Array(29,"Multi-Shot");

var aura = new Array(8);
aura[1]=new Array(28,"Conviction Aura Enchanted");
aura[2]=new Array(33,"Might Aura Enchanted");
aura[3]=new Array(35,"Holy Fire Aura Enchanted");
aura[4]=new Array(40,"Blessed Aim Aura Enchanted");
aura[5]=new Array(43,"Holy Freeze Aura Enchanted");
aura[6]=new Array(46,"Holy Shock Aura Enchanted");
aura[7]=new Array(49,"Fanaticism Aura Enchanted");

//Life,mana
var maxlife,maxmana;
maxlife = me.hpmax;
maxmana = me.mpmax;

//Cube Stuff
var stuffneed=new Object();

//Ping
var avping=0;

//global
var cast_rate; // number of frame for a normal spell

//Functions
function main()
{
	try {
		_main();
	} catch (pException) {
		var lTag = "Dae_Exception";
		writeLineToFile(lTag, "Exception: name="+pException.name+", message="+pException.message);
		writeObjectProperties(lTag, pException, "pException");
		quit();
	}
}

function writeLineToFile(pTag, pString)
{
	var lAccountName = (me.account=="")?"SinglePlayer":me.account;
	var lFile = fileOpen("output/"+lAccountName + "_" +me.name+"_"+pTag+".txt", 2);
	if(lFile) {
		lFile.writeLine(pString);
		print(pString);
		lFile.close();
	}
}

function writeObjectProperties(pTag, pObject, pName)
{
	if(pObject==null) {
		writeLineToFile(pTag, pName+"=null");
	} else {
		try {
			for (var i in pObject)
				writeLineToFile(pTag, pName+"["+i+"]="+pObject[i]);
		} catch (pException2) { }
	}
	writeLineToFile(pTag, " ");
}

function _main()
{
	me.gamelength=sets["game_length"]*1000;
	
	//Init TownMove object();
	Town=new TownMove();
	Town.Init();
		
	if (sets["begin_delay"]>0)
		delay(sets["begin_delay"]);

	begingame = (new Date()).getTime();

	if (me.version < 0.3916) {
		print("ÿc1This version of Bot requires core version ÿ2c0.29 ÿc1or higher");
		delay(5000);
		Abort();
	}

	if ( c_Sy_Constants_Version < 0.5 ) {
		print("ÿc1This version of Bot requires Sy_Constants ÿ2c0.5 ÿc1or higher");
		print("ÿc1You have probably installed another old bot, reinstall Daemon Multi-MF Bot");
		delay(5000);
		Abort();
	};

	checkclass();

	if (sets["load_preskiller"])
	{
		bprint("Loading ScaryKilling written by Shrek_III,all preskills settings in Dae_Multi_Set.d2l will be skipped!");
		load("bots/ScaryKilling.d2j");
	}

	DebugWrite("******************");
	DebugWrite("Daemon Multi-MF Bot "+CURRENT_VERSION);
	//Main switch board function.

    CheckErrors();
    //load("tools/Dae_Error.d2j");

    Initlistboss();

	//Check Immune
	checkimmune();

	//Logging
	LogLoad();
	LogSave(1);
	//LoadDictionary();

	//check quest,new in version 0.38c
	checkquest();

	//Times
    log["Total"]++;
	LogSave(0);

    if ( sets["use_shrine"] ) {
        //bprint("include ShrineLib");
        include("Dae_ShrineLib.d2l");
        ShrineLib["a_shrinePrefs"] = sets["a_shrinePrefs"];
        ShrineLib["shrineMaxDistance"] = sets["shrineMaxDistance"];
    };

    if ( sets["monothread"] ) {
      include("Dae_lifewatch.d2l");
      Init_Daelw();
     }
    else load("tools/Dae_lifewatchmain.d2j");

	//Drop item on cursor
	dropitemonhand();

	avping+=me.ping;

	// init townmove

	if ( sets["debug"] ){
		Town.Debug=true;
		Town.DebugLog=DebugWrite;
	}
	Town.BuyTPScrolls=sets["scroll_buy_percent"];
	if (!sets["tele_waypoint"]) Town.CanCastTelekinesis=function() { return false; };
	Town.BuyMPPots=sets["mp_pots_buy_percent"];
	Town.BuyHPPots=sets["use_hp_pots"]* sets["hp_pots_buy_percent"];
	Town.BuyTPScrolls=sets["scroll_buy_percent"];
	this.BuyAmmoPercent=sets["buy_ammo_amount"];
	this.RepairJavelinPercent=sets["repair_java_amount"];
	Town.ReviveMerc=sets["revive_merc"];
	Town.NeedStash=function() {  return (sthShopped || NeedStash(true) || ( sets["new_id_code"] && (IDList.nbStash+IDList.nbID>0))); }; 
	Town.NeedRepair=function() { return true; };
	Town.NeedHeal=function() { return true; };
	Town.StashCube=sets["fill_cube"];
	
	if (me.playertype){
		//hardcore
		bprint("ÿc1Hardcore character detected. Enter hardcore mode automaticlly");
		if (sets["chicken_hp"]<50) sets["chicken_hp"]=50;
		sets["chicken_nopot"]=true;
		sets["chicken_mercdead"]=true;
		sets["mana_recharge"]=false;
		sets["town_hp_no_pots"]=0;		
		sets["town_mp_no_pots"]=0;
	}
	
	//SnagIt
	PrepareSnagIt();
	if ( typeof( BMpwnItVersion ) != "undefined" )
		ShopItINIfile = sets["shop_ini"];
	
	//In Town
	begintown = (new Date()).getTime();
	InTown();
	
	avping+=me.ping;
	//Kill Bosses
	var fail=false;

	Loading.text="";

	var strboss="Kill bosses in line: ";

	if (sets["random_quest_count"])
	{
		var realcount=getBossCount().realcount;
		totalcount=getBossCount().totalcount;
		alwayscount=getBossCount().alwayscount;
		if (realcount<0) realcount=0;

		for(var i=0;i<sets["always_execute"].length;i++)
		{
			var bossn=sets["always_execute"][i]-1;
			if (listboss[bossn].quest) listboss[bossn].selected=true;
		}

		if (realcount>sets["min_quest_count"])
		{
			var randomcount=rnd(sets["min_quest_count"],realcount);
			for(i=0;i<randomcount;i++)
			{
				while(1)
				{
					var ranbossn=rnd(0,nlistboss-2);
					if (listboss[ranbossn].quest && !listboss[ranbossn].selected)
					{
						listboss[ranbossn].selected=true;
						break;
					}
				}
			}
			for(i=0;i<nlistboss-1;i++)
			{
				if (listboss[i].quest && !listboss[i].selected) listboss[i].quest=false;
			}
			bprint("You ordered ÿc2" + totalcount + " ÿc@bosses,the bot randomly chose ÿc2" + randomcount + "ÿc@ bosses, and you make ÿc2" + alwayscount + "ÿc@ bosses always be executed");
		}
	}

	if (sets["random_boss"])
	{
		switch (me.area)
		{
			case 1:
				randomline[0]=nCountess+1;
				k=1;
				break;
			case 3:
				if (rnd(0,1)==0){
					randomline[0]=nMephisto+1;
					randomline[1]=nStormtree+1;
				}
				else
				{
					randomline[1]=nMephisto+1;
					randomline[0]=nStormtree+1;
				}
				k=2;
				break;
			default:
				k=0;
		}

		for(var j=k;j<nlistboss-1;j++)
		{
			while(1)
			{
				var foundnum=false;
				rannum=rnd(1,nlistboss-1);
				for(i=0;i<randomline.length;i++)
				{
					if (randomline[i]==rannum)
					{
						foundnum=true;
						break;
					}
				}
				if (!foundnum)
				{
					if ( sets["random_group"] ) { // in random group, we have to begin in order
					    if ( rannum-1 == nDacFarren )
						    rannum = nShenk+1;
					    if ( rannum-1 == nThresh )
						    rannum = nEldritch+1;
					    if ( rannum-1 == nNihlathak )
						    rannum = nPindle+1;
					};
					randomline[j]=(rannum);

					if ( sets["random_group"] ) {
					    if ( rannum-1 == nShenk ) {
						    j++;
							randomline[j]=nDacFarren+1;
					    };
					    if ( rannum-1 == nEldritch ) {
						    j++;
							randomline[j]=nThresh+1;
					    };
					    if ( rannum-1 == nPindle) {
						    j++;
							randomline[j]=nNihlathak+1;
					    };
					};
					break;
				}
			}
		}
		ExchangeBoss(me.area);
	}
	else
		randomline=sets["order_boss"];

	// cows have to be done last...  just because of kinglifewatch.d2j!!!
	var i=-1;
	do {
	     i++;
	} while ((i < randomline.length) && (randomline[i] != nCows + 1));
	if (randomline[i] == nCows + 1)
	{
	  for (var j=i;j<randomline.length - 1;j++)
	  {
	      var tmp = randomline [j+1];
		  randomline[j] = tmp;
	  }
	  randomline[randomline.length - 1] = nCows + 1;
	}

	var index = 1;
	for( var j = 0 ; j < randomline.length ; j++ )
	{
        	//if ( !listboss[randomline[j]-1].quest )
		//    continue;

		var boss = listboss[ randomline[j]-1 ];
		if ( boss.quest ) {
			strboss+= "  " + index + " - " + boss.name;
			index++;
		};

	};
	bprint(strboss);

	if (getBossCount()==0 && sets["prevent_no_boss"])
	{
		if (!sets["random_boss_list"].length) listboss[0].quest=true;
		else
		{
			var n = rnd(0,sets["random_boss_list"].length-1);
			var n2 = sets["random_boss_list"][n]-1;
			listboss[n2].quest=true;
			bprint("You disabled all bosses!Bot randomly chose ÿc2" + listboss[n2].name + "ÿc@ for target!");
		}
	}
	
	for(var j=0;j<nlistboss-1;j++)
	{
        	if ( !randomline[j] )
		    continue;

		var boss = listboss[ randomline[j]-1 ];
		if ( boss.quest ) {

			DebugWrite("Begin quest "+boss.name );

			var savdelay = sets["snag_delay"];
			var savkilluniqueboss = sets["kill_uniqueboss"];

		    if ( boss == bossshenk )
			    sets["snag_delay"] = sets["snag_delayshenk"];
		    if ( boss == bosscountess )
			    sets["kill_uniqueboss"] = sets["unique_before_countess"];
		    if ( boss == bossmeph )
		    	sets["kill_uniqueboss"] = sets["unique_before_meph"];
		    if ( boss == bosscreeping )
		    	sets["kill_uniqueboss"] = sets["unique_before_creeping"];

		    bprint ("Now starting to kill ÿc2" + boss.name);
            	    if ( !DoBoss( boss.GotoBoss, boss ) ) fail = true;

		    sets["snag_delay"] = savdelay;
		    sets["kill_uniqueboss"] = savkilluniqueboss;

			LogSave(0);
        		ShowBar2();
			DebugWrite("End quest "+boss.name );
		};
    };

    if (boss=listboss[11] && me.area==102 && sets["meph_portal_to_act4"]) GoPortal();

    log["Finish"]++;
	if (!fail)
	{
        log["Success"]++;
		bprint("Successfully killed all the bosses you ordered!");
	}
    LogSave(1);

	avping+=me.ping;

	log["Ping"]+=(avping/3);

	//Logging
	LogSave(1);

	DebugWrite("Normal end");
	if ( sets["finish_in_town"] ) {
		UseTP();
		InTown();
		ShowState("Grabbing potions for next game");
		if (sets["grab_potions_at_end"]) {
			Town.MoveTo("portalspot",me.act);
			var temp = snagrad;
			snagrad=60;
			SnagIt(sets["snag_ini"]);
			snagrad=temp;
		}
	};

    if ( sets["nextscript"].length > 0 )
    {
      	print("lifewatch stop");
      	UseTP();
 		DoDel(500);
      	load( sets["nextscript"] );
    }
    else {
  	  bprint("Gotta leaving. See ya next game!");
  	  delay(500);
  	  quit();
    };
}

function getBossCount()
{
	var bosscount=0;
	for(i=0;i<nlistboss-1;i++)
	{
		if (listboss[i].quest) bosscount++;
	}
	var ac=0;
	var totalcount=bosscount;
	for(i=0;i<sets["always_execute"].length;i++)
	{
		if (listboss[sets["always_execute"][i]-1].quest)
		{
			ac++;
			bosscount--;
		}
	}

	return {alwayscount:ac,realcount:bosscount,totalcount:totalcount};
}

function ExchangeBoss(area)
{
	switch (area)
	{
		case 3:
			for(i=0;i<nlistboss-1;i++)
			{
				if (randomline[i]==nCountess+1 && i<nlistboss-2)
				{
					var tempboss=randomline[nlistboss-2];
					randomline[nlistboss-2]=nCountess+1;
					randomline[i]=tempboss;
					break;
				}
			}
			break;
		case 1:
			for(i=0;i<nlistboss-1;i++)
			{
				if(randomline[i]==nMephisto+1 && i<nlistboss-2)
				{
					var tempboss=randomline[nlistboss-2];
					randomline[nlistboss-2]=nMephisto+1;
					randomline[i]=tempboss;
					break;
				}
			}

			break;
	}

}

function GoPortal()
{
	Teleport(17596,8070,10,2);
	DoDel(300);
	ChangeArea("Portal",103);
}

function UseTP()
{
	if ( !Town.InTown() )
	{
        	if ( ( me.area == 121 ) && ( !sets["tpafterpindle"] ) )
        	{
        		// pindle area
          		if (PindleBack()) return true;
        	};

		if ( me.classid != 1 )
			PreSkill( false, true );

		DebugWrite("Return to town");
		if (!Town.GotoTown())
		{
			DebugWrite("GoTown: Failed to go to town");
			bprint("GoTown: Failed to go to town");
			Abort();
		}
		DebugWrite("We are in town, area "+me.area);
	}
}

function PrepareSnagIt()
{
	DebugWrite("preloading snagit ini: " + sets["snag_ini"]);
//	delay(100);
	getINI(sets["snag_ini"]);
//	delay( 500 ); // strange behaviour if no delay and Debugwrite working
	DebugWrite("snagit ini loaded");
}

function GetExperience()
{
	var e = me.getStat(13);
	if (e < 0)
		return (e + 0xFFFFFFFF + 1);
	return e;
}

function CheckErrors()
{
	me.quitonerror = 1; //zz

	var myerror = me.lasterror;
		
	if (myerror) {
		bprint("Last time we had an error : " + myerror);
		DebugWrite(" * SCRIPT ERROR: " + myerror);
		var f = fileOpen(Dae_error_log, 2);
		if (f) {
			re=/.c\d/;
			while(myerror.match(re))
			{
				myerror=myerror.replace(re,"");
			}
			re2=/line./;
				myerror=myerror.replace(re2,"line <font color=blue>");
			re3=/.{2}error:/;
				myerror=myerror.replace(re3,"</font> error:<font size=2 face=\"Arial\" color=#996633><b>");
			re4=/: :/;
				myerror=myerror.replace(re4," -");
				 
			var d = new Date();
			f.writeLine("< <i>" + me.name + "</i> > " + "<font color=green> [ " + d.toLocaleString() + " ]</font> <b>" + CURRENT_VERSION + "</b> <font color=red>" + myerror + "</b></font></font><br>");
			f.close();
		}
		else {
			DebugWrite(" * ERROR: Failed to open errorlog.txt");
		}
	}
}

function CheckMe()
{
  if ( sets["monothread"] )
    Loop_Daelw();
  
  if (sets["dodge_missiles"] && me.classid==1)
  	CheckMissile();
}

//**In Town Functions
function InTown(parameter)
{
    var begintown = (new Date()).getTime();
    sthShopped = false;
	anyashopped = false;

    // check switch
    if (!(parameter & 1) && me.classid!=0 && me.classid!=3) doWeaponSwitch( sets["initial_switch"] );
	
	if (!(parameter & 1) && me.classid==0) {
		check = getUnit(4);
		if (check) do
		{
			if(check.itemloc == 11 || check.itemloc == 12)
			{
				if((check.itemtype == 87 || check.itemtype == 44 || check.itemtype == 43 || check.itemtype == 42)){
					doWeaponSwitch();
					break;
				}
			}
		} while (check.getNext());
		WEA_JAV=weaponSwitch(1);
		WEA_BOW=(WEA_JAV==0)? 1 : 0 ;
	}
	
	if (!(parameter & 1) && me.classid==3) {
		var twosolts=false;
		var secondDam=0;
		var firstDam=0;
		
		check = getUnit(4);
		if (check) do
		{
			if((((check.itemloc == 11 || check.itemloc == 12) && weaponSwitch(1)==0) || ((check.itemloc==4 || check.itemloc==5) && weaponSwitch(1)==1)) && check.getParent()){
				if (check.getParent().name==me.name){
					if (check.itemtype!=2 && check.itemtype!=70 && check.itemtype!=51){
						twosolts=true;
						secondDam=(check.getStat(21)+check.getStat(22))/2;
						//doWeaponSwitch();
					}
				}
			}
		} while (check.getNext());
		
		if (!twosolts) {
			WEA_BH=weaponSwitch(1);
			WEA_ZEAL=weaponSwitch(1);
		}
		else{
			check = getUnit(4);
			if (check) do
			{
				if((((check.itemloc == 11 || check.itemloc == 12) && weaponSwitch(1)==1) || ((check.itemloc==4 || check.itemloc==5) && weaponSwitch(1)==0)) && check.getParent())
				{
					if (check.getParent().name==me.name){
						if (check.itemtype!=2 && check.itemtype!=70 && check.itemtype!=51){
							//me.overhead("it's me : " + check.name);
							firstDam=(check.getStat(21)+check.getStat(22))/2;
						}
					}
				}
			} while (check.getNext());
			
			
			if (firstDam > secondDam){
				WEA_BH=1;
				WEA_ZEAL=0;
			}
			else{
				WEA_BH=0;
				WEA_ZEAL=1;
			}
			doWeaponSwitch(WEA_BH);
		}
	}
	DebugWrite("InTown");
	GetCorpse();

	var bNeedScrools = Town.NeedScrolls();
    if ( !sets["new_id_code"] )
	    NeedIdScrolls(); //global need_id_scrolls is evaluated
	var bNeedPots = Town.NeedPots();
	needkey=NeedKeys();

	DoPotions();

	if (parameter & 2) CheckInv(true);
	else CheckInv();
    CheckEquip();

	var poison = sets["healifcursed"] && me.getState(2);
	var cursed = sets["healifcursed"] && me.getState(9);
	frozen = sets["healifcursed"] && me.getState(11);

	var merc=Town.GetMerc();
	if (merc && sets["healifcursed"] )
	{
		poison=merc.getState(2) || poison;
		cursed=merc.getState(9) || cursed;
		//var mercfrozen=sets["healifcursed"] && merc.getState(11);
	};

	var needshop = ( MyGold() >= sets["mingoldshop"] );
	if ( needshop ) {
		var rndshoprate=rnd(1,100);
		var shoprate;
		if ( me.act != 1 )
			shoprate = sets["shop_rate"];
		else
			shoprate = sets["shop_rate_act1"];
		needshop = (rndshoprate <= shoprate);
	};
	
	var setneedgamble=(sets["gamble_circlet"] || sets["gamble_amulet"] || sets["gamble_ring"]);
	var needgamble = ( MyGold() >= sets["mingoldgamble"] && setneedgamble)
	if (needgamble)
	{
		var rndgamblerate=rnd(1,100);
		needgamble= (rndgamblerate <= sets["gamble_rate"]);
	}

    var bNeedIDOrSell;
    if ( !sets["new_id_code"] )
        bNeedIDOrSell = ( need_id_scrolls > 0 )
    else {
        IDList = new GetIDList();
        bNeedIDOrSell = IDList.NeedIdOrSell(sets["sell_items"]);
    };

	if (bNeedPots || bNeedScrools || checkheal(0,1) || bNeedIDOrSell ||
        needshop || poison || cursed || frozen || (needkey>0 && me.act != 3 ) ||
		tome_count==0 )
	{
		//print(tome_count);
		ShowState("Walking to Healer");
		
		if (me.area==2 && (need_id_scrolls>0)){
			Town.MoveTo("malah",5);
			Town.Heal(HealFunc,false);
		}
		else
			Town.Heal(HealFunc,false);
	}

    if ( sets["new_id_code"] ) {
        if ( !bNeedIDOrSell )
            IDList.Check( true );

        if ( IDList.nbDrop )
            IDList.Drop();
    };

	var nr=checkrepair();
	if (nr || needshop || (needkey>0 && me.act == 3 ) || Town.NeedAmmo())
	{
		ShowState("Repairing");
		Town.Repair(RepairFunc,false,nr);
	}

	if (sthShopped || NeedStash(true) || ( sets["new_id_code"] && (IDList.nbStash+IDList.nbID>0)  ) ) {
		DebugWrite("Going to stash");
		Town.Stash(StashFunc,false);
		PrepareSnagIt();
	}
	DebugWrite("Stashing done");

	if (checkmerc())
	{
		ShowState("Revive merc");
	    Town.Revive(true);
	}

	if (sets["shop_anya"] && needshop )
	{
		ShowState("Shopping at Anya's");
		DoShop( "anya", Sc_MonsterClassID_Anya, true, true );
		anyashopped=true;
	}

	if (sets["gamble"] && needgamble )
	{
		ShowState("Going to gamble!");
		for(i=0;i<sets["max_gamble_one_run"] && MyGold() >= sets["mingoldgamble"];i++)
		{
			var npc=GoGamble();
			if (npc)
			{
				var gidlist = GambleIt(npc.name,npc);
				var retries=0;
				while(retries++<5 && getUIFlag(0x08))
				{
					me.cancel(1);
					//npc.cancel(1);
					delay(500);
				}
				if (getUIFlag(0x08)) me.cancel(1);
				if (gidlist && gidlist.length)
				{
					item=getUnit(4,null,100);
					if (item) do
					{
						for(i=0;i<gidlist.length;i++)
						{
							var nowgid=gidlist[i];
							if (item.gid==nowgid) Town.StashItem(item);
						}
					}while(item && item.getNext())
				}
			}
		}
	}


    // time elapsed in town is substracted
    var actualtime = (new Date()).getTime() - begintown;
    log["TimeInTown"] += ( actualtime );
    timelost += ( actualtime );
}

function NeedKeys()
{
    if ( !sets["buy_key"] )
        return 0;

	mykey=GetKeys();
	if (!mykey)
	{
		need_key=12;
		return 2;
	}

	if (mykey)
	{
		quan=mykey.getStat(70);
		need_key=12-quan;
		if (Math.floor((quan * 100) / 12) <= sets["keys_buy_percent"]) return 1;
	}

	return 0;
}

function GetKeys()
{
	var item = getUnit(4, "key", 100);
	do {
		if (item && item.mode == 0 && item.itemloc == 0 && item.getParent() && item.getParent().name == me.name) {
			return item;
		}
	}while(item && item.getNext());

	return null;
}

function freespace()
{
	var invspace=new Array(4);
	invspace[0]=new Array(10);
	invspace[1]=new Array(10);
	invspace[2]=new Array(10);
	invspace[3]=new Array(10);
	for (y = 0; y < 4; y++)
	{
		for (x = 0; x < 10; x++)
		{
			invspace[y][x] = "empty";
		}
	}

	invitem = getUnit(4,null,100);
	freespaces = 40;
	iis = 0;
	if (invitem) do
	{
		owner = invitem.getParent();
		if (owner)
		{
			if (owner.name == me.name)
			{
				invitemy = invitem.y;
				invitemx = invitem.x;
				iis++;
				for (y = 0; y < GetSizeY(invitem); y++)
				{
					for (x = 0; x < GetSizeX(invitem); x++)
					{
						invspace[y + invitemy][x + invitemx] = "full";
						freespaces -= 1;
					}
				}
			}
		}
	} while (invitem.getNext(null,100));

	return freespaces;
}

function dropitemonhand()
{
	while(me.itemoncursor) {
		bprint("I have an item on my cursor");
		var item = getUnit(4, null, 4);
		if (item) {
			print("dropping item: " + item.name);
			item.cancel(0);
			delay(500);
		}
	}
	return true;
}

function GetCorpse()
//get the char's corpse...
{
	var corpse = getUnit(0, me.name, 17);
	while (corpse)
	{
		walkto(corpse.x,corpse.y);
		delay(500);
		ClickMap(corpse);
		delay(500);
		died=true;
		log["Died"]++;
		corpse = getUnit(1, me.name, 17);
	}
}

function checkmerc()
{
	var needmerc=true;
	if (sets["revive_merc"])
	{
		needmerc = true;
		var merc = getUnit(1);
		if (merc) do
		{
			if(merc.classid!=271 && merc.classid!=338 && merc.classid!=359 && merc.classid!=561)
				continue;
			if (merc.getParent() && merc.getParent().name == me.name)
			{
				if (merc.hp > 0)
				{
					mercname = merc.name;
					bprint("My Mercenary "+mercname+" is alive!");
					needmerc = false;
					return false;
				}
			}
		} while(merc && merc.getNext());
		if (needmerc)
		{
			goldamount = MyGold();
			if (goldamount < 50000)
			{
				bprint("Not enough gold to revive Mercenary!!!");
				needmerc = false;
				return false;
			}
		}
		return true;
	}
}

function CheckMerc()
{
	var merc = getUnit(1);
	if (merc) do
	{
		if(merc.classid!=271 && merc.classid!=338 && merc.classid!=359 && merc.classid!=561)
			continue;
		if (merc.getParent() && merc.getParent().name == me.name)
		{
			if (merc.hp > 0)
				return true;
			else
				return false;
		}
	} while(merc && merc.getNext());
	
	return false;
}

function checkclass()
{
	//check my class
	if (me.classid != 1 && me.classid != 4 && me.classid!=0 && me.classid!=3)
	{
		quitmessage("This bot is only for Sorc/Barb/Javazon/Pally ! Stop script now...");
		stop();
	}
}


function checkrepair()
{
	var lowestitem = 100;
	var currentitem = 0;
	var obj = getUnit(4, null, 1);
	do	{
		if(obj && obj.mode == 1) {
			var parent = obj.getParent();
			if (parent && parent.name == me.name && !obj.getFlag(0x400000)) {
				var dur = obj.getStat(72);
				var max_dur = obj.getStat(73);
				if ( max_dur ) {
                    currentitem = (dur * 100) / max_dur;
                    if ( currentitem < sets["repair_percent"] ) {
					    bprint("Need to repair");
					    return true;
                    };
				    if ( currentitem < lowestitem )
                        lowestitem = currentitem;
                };
			}
		}
	}while(obj && obj.getNext(null,1));

	bprint("I don't need to repair!  Lowest item is at %" + parseInt(lowestitem) + " durability");
	return false;
}


function checkheal(mode,mode2)
//SETTINGS for mode:
//0=In town(for healing)
//1=Out of town(for drinking normal life potion)
//2=Out of town(for drinking normal mana potion)
//3=Out of town(for drinking rej potion)
//4=Out of town(for drinking full rej potion)
//5=chicken
{
//check whether you need to heal
	var mymaxlife,mymaxmana,skiplife,skipmana,lifethreshold,manathreshold;
	switch(mode)
	{
		case 0:skiplife=sets["malah_hp"];skipmana=sets["malah_mp"];break;
		case 1:skiplife=sets["heal_hp"]; skipmana=20; break;
		case 2:skiplife=sets["heal_hp"]; skipmana=20; break;
		case 3:skiplife=sets["heal_hp"]; skipmana=sets["heal_mp"]; break;
		case 4:skiplife=sets["heal_hp"]; skipmana=sets["heal_mp"];break;
		case 5:skiplife=sets["chicken_hp"];skipmana=-1;
	}
	mymaxlife = me.hpmax;
	mymaxmana = me.mpmax;

	lifethreshold = parseInt((mymaxlife * skiplife) / 100);
	manathreshold = parseInt((mymaxmana * skipmana) / 100);

	if (mode!=1 && mode!=2)
	{
		if (me.hp < lifethreshold || me.mp < manathreshold)
		{
				if (mode2==1) bprint("I Need to heal");
				return true;
		}

//v0.32		if (mode2==1) bprint("I don't need to heal!");
	}
	else if (mode==1)
	{
		if (me.hp < lifethreshold) return true;
	}
	else if (mode==2)
	{
		if (me.mp < manathreshold) return true;
	}
}

function CheckInv(noyps)
{
	//taken from sca's multi-mf bot!thanks goes to scav ???
	DebugWrite("CheckInv started");

	dropitemonhand();

	var item = null;
//	if (died) {
		DebugWrite("Died previous game, dropping potions from inv");
		//no matter died or not,drop potions //0.47
		item = getUnit(4, null, 100);
		looprestart: do {
			if (item && item.mode == 0 && item.itemloc == 0 && (item.code == "rvs" || item.code == "rvl" || IsLifePot(item) || item.code == "yps" || item.code=="vps" || item.code == "wms" ))
			{
				if (noyps && item.code=="yps") continue;
				DebugWrite("Found potion in inv");
				par = item.getParent();
				if (par && par.name == me.name) {
					DebugWrite("I am owner of the potion lets drop it");
					while(item.mode != 4) {
						clickItem(0, item);
						delay(250);
					}
					item.cancel(0);
					delay(500);
					DebugWrite("potion dropped");
					item = getUnit(4, null, 100);
					continue looprestart;
				}
			}
		}while(item && item.getNext(null, 100));
		DebugWrite("Dropping potions done");
//	}

    CheckInvForPots()

	DebugWrite("Looking for tomes in inv");
	// check for tomes
	best_tome = 0;
	tome_count = 0;
	item = getUnit(4, "tbk", 100);
	do {
		if (item && item.mode == 0 && item.itemloc == 0 && item.getParent() && item.getParent().name == me.name) {
			DebugWrite("Found a tome with " + item.getStat(70) + " scrolls");
			tome_count++;
			best_tome = Math.max(item.getStat(70), best_tome);
		}
	}while(item && item.getNext("tbk", 100));

	DebugWrite("Tomes lookup done");

    if ( !tome_count )
		bprint("No tomes found,Inventory checked!");

	if (tome_count > 1) {
		DebugWrite(" * WARNING: Too many tomes detected in inventory, count: " + tome_count);
		item = getUnit(4, "tbk", 100);
		tomeloop: do {
			if (item && item.code == "tbk" && item.mode == 0 && item.itemloc == 0 && item.getParent() && item.getParent().name == me.name) {
				if (item.getStat(70) < best_tome) {
					DebugWrite(" * WARNING: Dropping tome, got better one (quantity: " + item.getStat(70) + ")");
					//item.interact();
					while(item.mode != 4) {
						clickItem(0, item);
						delay(250);
					}
					item.cancel(0);
					delay(500);
					item = getUnit(4, "tbk", 100);
					continue tomeloop;
				}
			}
		}while(item && item.getNext("tbk", 100));
	};

	//keys
	best_key = 0;
	key_count = 0;

	item = getUnit(4, "key", 100);
	do {
		if (item && item.mode == 0 && item.itemloc == 0 && item.getParent() && item.getParent().name == me.name) {
			DebugWrite("Found " + item.getStat(70) + " keys");
			key_count++;
			best_key = Math.max(item.getStat(70), best_key);
		}
	}while(item && item.getNext("key", 100));

	if (key_count > 1) {
		DebugWrite(" * WARNING: Too many keys detected in inventory, count: " + key_count);
		item = getUnit(4, "key", 100);
		keyloop: do {
			if (item && item.code == "key" && item.mode == 0 && item.itemloc == 0 && item.getParent() && item.getParent().name == me.name) {
				if (item.getStat(70) < best_key) {
					DebugWrite(" * WARNING: Dropping tome, got better one (quantity: " + item.getStat(70) + ")");
					//item.interact();
					while(item.mode != 4) {
						clickItem(0, item);
						delay(250);
					}
					item.cancel(0);
					delay(500);
					item = getUnit(4, "key", 100);
					continue keyloop;
				}
			}
		}while(item && item.getNext("key", 100));

	}
	
	DrinkSmallPot();
//v0.32	bprint("Inventory checked!");
}

function DrinkSmallPot()
{
	if (me.diff==1){
		pot=getUnit(4,null,2);
		if (pot) do{
			if (pot.code.match(/hp[1-3]/) || pot.code.match(/mp[1-3]/))
			{
				clickItem(0,pot);
				var retries=0;
				while(pot.mode!=4 && retries++ < 5){
					delay(500);
					if (retries % 2 == 0) clickItem(0,pot);
				}
				if (pot.mode==4) pot.cancel(0);
			}
		}while(pot && pot.getNext(null,2));
	}
	
	if (me.diff==2){
		pot=getUnit(4,null,2);
		if (pot) do{
			if (pot.code.match(/hp[1-4]/) || pot.code.match(/mp[1-4]/))
			{
				clickItem(0,pot);
				var retries=0;
				while(pot.mode!=4 && retries++ < 5){
					delay(500);
					if (retries % 2 == 0) clickItem(0,pot);
				}
				if (pot.mode==4) pot.cancel(0);
			}
		}while(pot && pot.getNext(null,2));
	}
}
				
		

// i take too from scanvenger multi bot MF
function CheckInvForPots()
{
	DebugWrite("Checking if potions in inv");

	DebugWrite("Inv check loop");
	var item = getUnit(4, null, 100);
	goherebitch: do {
		done = true;
		if (item && item.mode == 0 && item.itemloc == 0)
		{
			if (item.code == "rvs" || item.code == "rvl" || IsLifePot(item) || IsManaPot(item)) {
				DebugWrite("Found potion in inventory");
				var par = item.getParent();
				if (par && par.name == me.name) {
					DebugWrite("I am owner of the potion, lets drink it: " + item.code);
					clickItem(1, item);
					DebugWrite("Drinking pot done");
					delay(500);
					item = getUnit(4, null, 100);
					continue goherebitch;
				}
			}
			else if (item.code == "isc") {
				DebugWrite("Found ID scroll in inv, dropping it");
				while(item.mode != 4) {
					clickItem(0, item);
					delay(500);
				}
				while(item.mode == 4) {
					item.cancel(0);
					delay(500);
				}
				DebugWrite("ID scroll dropped");
				item = getUnit(4, null, 100);
				continue goherebitch;
			}
		}
	}while(item && item.getNext(null, 100));

	DebugWrite("Inventory checked for potions and scrolls");
}

// sorry again from scavenger (but the itemloc properties is not documented)
function CheckEquip()
{
	if (me.classid==0 || me.classid==3) {
		sets["weapon_switch"]=false;
		return;
	}
	
	DebugWrite("CheckEquip started");

	var fcr = 0;
	var select_fcr = 0;
	var switch_fcr = 0;
	var char_mf = 0;
	var merc_mf = 0;
	var select_mf = 0; // MF with wea/shield in actual equip
	var switch_mf = 0; // MF with wea/shield in second equip
	var ws1 = 0; // number of items in equip I
	var ws2 = 0; // number of items in equip II

	var merc_level = 0;
	var merc = getMerc();
	if (merc)
		merc_level = merc.getStat(12);
	level = me.getStat(12);	// get char level

	DebugWrite("Starting item check loop");
	var item = getUnit(4);
	do {
		if (item) {
			if (item.mode == 1 && item.getParent()) {
//                DebugWrite( "item "+item.fname+" loc "+item.itemloc );
				switch(item.itemloc) {
					case 4: // own or merc shield/weapon
						if (item.getParent().name == me.name) {
							ws1++;
							select_mf += item.getStat(80); // mf
							select_mf += level * item.getStat(240) / 8; // mf per level (divide by 8
							select_fcr += item.getStat(105); // fcr
						}
						else {
							merc_mf += item.getStat(80);
							merc_mf += merc_level * item.getStat(240) / 8;
						}
						break;
					case 5: // own or merc shield/weapon
						if (item.getParent().name == me.name) {
							ws1++;
							select_mf += item.getStat(80);
							select_mf += level * item.getStat(240) / 8;
							select_fcr += item.getStat(105);
						}
						else {
							merc_mf += item.getStat(80);
							merc_mf += merc_level * item.getStat(240) / 8;
						}
						break;
					case 11:
						ws2++;
						switch_mf += item.getStat(80);
						switch_mf += level * item.getStat(240) / 8;
						switch_fcr += item.getStat(105); // fcr
						break;
					case 12:
						ws2++;
						switch_mf += item.getStat(80);
						switch_mf += level * item.getStat(240) / 8;
						switch_fcr += item.getStat(105); // fcr
						break;
					default:
						if (item.getParent().name == me.name) {
							char_mf += item.getStat(80);
							char_mf += level * item.getStat(240) / 8;

							fcr += item.getStat(105);
						}
						else {
							merc_mf += item.getStat(80);
							merc_mf += merc_level * item.getStat(240) / 8;
						}
				}
			}
			// check charms
			else if (item.mode == 0 && item.itemloc == 0 && (item.code == "cm1" || item.code == "cm2" || item.code == "cm3")) {
				/////fcr detect??
				char_mf += item.getStat(80);
				char_mf += level * item.getStat(240) / 8;
			}
		}
	}while(item && item.getNext());
    DebugWrite("ws1 "+ws1+" ws2 "+ws1+" select_mf "+select_mf+" switch_mf "+switch_mf );

	DebugWrite("Item check loop done");

	// if nothing in some equip, disable switch
    if ( ws1 == 0 ) {
        sets["weapon_switch"] = false;
		doWeaponSwitch();
		fcr += switch_fcr;
		bprint("nothing in this equipement, switch and disable switch");
    };
    if ( ws2 == 0 ) {
        sets["weapon_switch"] = false;
		bprint("nothing in second equipement, disable switch");
    };
	DebugWrite("Weapomswitch check done");

	// check if both slots are filled
    // think swithing is only good for more MF (a gold sorceress :lol: is the exception but it is a MF bot)
    if ( sets["weapon_switch"] && ( select_mf >= switch_mf  ) ) {
		bprint("less MF in second equipement, disable switch");
        sets["weapon_switch"] = false;
    };

    // i keep that because to have the best attack rate we need the casting time
	cast_rate = GetCastRate(fcr);
	DebugWrite("CheckEquip done");
}

function IsLifePot(item)
{
	return (item.code == "hp1" || item.code == "hp2" || item.code == "hp3" || item.code == "hp4" || item.code == "hp5");
}

function IsManaPot(item)
{
	return (item.code == "mp1" || item.code == "mp2" || item.code == "mp3" || item.code == "mp4" || item.code == "mp5");
}

function getMerc()
{
	merc = Town.GetMerc();
	return merc;
}


//-----------------------------------------------------

//**Messages Functions

function bprint(what)
{
//Bot information display(bot print)
  if ( what )
	print("ÿc3:: ÿc@ " + what);
  else
	print("ÿc3:: ÿc@ error in code" );
}

function dprint(what)
{
  // dump
}

function ShowState(what)
{
	//removed
}

//**Move and Path Functions
//added this!
function ChangeArea(how,des,where)	//How to change, your destination area, and for waypoints the area to change to
{
	var portal = getUnit(2,how);

	var i = 0;
	while (!portal && i++ < 3)
	{
		print("Waiting to detect the " +how);
		DoDel(100);
		portal = getUnit(2,how);
	};

	if (!portal)
	{
		print("ÿc1::ÿc@ "+ how + " not Found!");
		return false;
	};
	walkto(portal.x, portal.y);
	if(how=="Waypoint") portal.interact(where);
	else ClickMap(portal);
	i=0;
	while(me.area != des)
	{
		DoDel(20);
		if (i == 50)
		{
			walkto(portal.x, portal.y);
			if(how=="Waypoint") portal.interact(where);
			else ClickMap(portal);
		}
		if (i >= 100)
		{
			print("ÿc1::ÿc@ Use " + how + " Failed!");
			return false;
		}
		i++;
	};
	if(how=="Waypoint") MenuCancel(portal,0);
	DoDel(100);
	print("Area changed in " +parseInt(i*20+100) +" ms!");
	return true;
}

function ChangeArea2(how,des,where)	//How to change, your destination area, and for waypoints the area to change to
{
	var portal = getUnit(2,how);

	var i = 0;
	while (!portal && i++ < 3)
	{
		print("Waiting to detect the " +how);
		DoDel(100);
		portal = getUnit(2,how);
	}

	if (!portal)
      return false;

	walkto(portal.x, portal.y);
	if(how=="Waypoint") portal.interact(where);
	else ClickMap(portal);
	i=0;
	while(me.area != des)
	{
		DoDel(20);
		if (i == 50)
		{
			walkto(portal.x, portal.y);
			if(how=="Waypoint") portal.interact(where);
			else ClickMap(portal);
		}
		if (i >= 100)
            return false;
		i++;
	}
	if(how=="Waypoint") MenuCancel(portal,0);
	DoDel(100);
	bprint("Area changed in " +parseInt(i*20+100) +" ms!");
	return true;
}

function ClickMap(x,y)
{
	if (arguments.length==1)
	{
		if (!x) return false;
		clickMap(0,0,x);
		delay(rnd(10,50));
		clickMap(2,0,x);
	}
	else if(arguments.length==2)
	{
		
		clickMap(0, 0, x, y);
    		delay(rnd(10,50));
    		clickMap(2, 0, x, y);
    	}
}

function walkto(x, y){
	var arrived = false;
	var tried = 0; //xx2
	while((arrived==false) && (tried++<20) ) { //v0.27
		ClickMap(x, y);
		delay(100);
        CheckMe();
		if((Math.abs(me.x - x) < 4) && (Math.abs(me.y - y) < 4)) arrived=true;
	}
}

function teleportto(x, y)
{
	if(sets["random_move"])
	{
		x+=rnd(-1,1);
		y+=rnd(-4,4);
	}
	for (rv = 0; rv < 5; rv++)
	{
		DoCasting("Teleport",0,x,y);
		// Check to see see if we have arrived at our destination
		if ((Math.abs(me.x - x) < 6) && (Math.abs(me.y - y) < 6))
		{
			//dprint("Teleported to [" + me.x + ", " + me.y + "]");
			return true;
		}
	}
	return walkto(x, y);
}

//**Skill Functions

function DoCasting(which,usehand,x,y)
{
	if (!isNaN(which)) which=parseInt(which);
	
	for (qw = 0; qw < 100; qw++)
	{
		if(!me.itemoncursor) break;
		DoDel(20);
	}
	if(me.itemoncursor) dropitemonhand;

	while(me.mode == 10) delay(20); //xx
    CheckMe();

	if ( Sc_SetSkill(which,usehand) )
	{
		switch(arguments.length)
		{
			case 0: break;
			case 2: CastSkillAt(usehand); break;
			case 3:	CastSkillAt(usehand,x);break;
			case 4: CastSkillAt(usehand,x,y); break;
		}
        delay(50);
        while (me.mode==10) delay(20);
        CheckMe();
		return true;
	} else return false;
}

function CastSkillAt(usehand,x,y)
{
	if (usehand==0) {
		var mouse_key=3;
		var shift_key=0;
	}
	else 
	{
		var shift_key=1;
		var mouse_key=0;
	}
	
	if (arguments.length==2)
	{
		//if (myDist(x.x,x.y)>25) return;
		clickMap(mouse_key,0,x);
		delay(rnd(10,50));
		clickMap(mouse_key+2,0,x);
	}
	else if (arguments.length==3)
	{
		//if (myDist(x,y)>25) return;
		clickMap(mouse_key,shift_key,x,y);
		delay(rnd(10,50));
		clickMap(mouse_key+2,shift_key,x,y);
	}
	else if(arguments.length==1)
	{
		clickMap(mouse_key,shift_key,me.x,me.y);
		delay(rnd(10,50));
		clickMap(mouse_key+2,shift_key,me.x,me.y);
	}
}

function DoCast(which,usehand,x,y)
{
	for (qw = 0; qw < 100; qw++)
	{
		if(!me.itemoncursor) break;
		DoDel(20);
	}
	if(me.itemoncursor) dropitemonhand;

	while(me.mode == 10) delay(20); //xx
    CheckMe();

	if ( Sc_SetSkill(which,usehand) )
	{
		switch(arguments.length)
		{
			case 0: break;
			case 2: CastSkillAt(usehand); break;
			case 3:	CastSkillAt(usehand,x);break;
			case 4: CastSkillAt(usehand,x,y); break;
		}
        delay(50);
        while (me.mode==10) delay(20);
        CheckMe();
		return true;
	} else return false;
}

function DoAttackSequence(which,usehand,x,y)
{
	for (qw = 0; qw < 100; qw++)
	{
		if(!me.itemoncursor) break;
		DoDel(20);
	}
	if(me.itemoncursor) dropitemonhand;

	while(me.mode == 10 || me.mode == 18 || me.mode == 7 || me.mode == 8 ) delay(20);
	CheckMe();

	if ( Sc_SetSkill(which,usehand) )
	{
		switch(arguments.length)
		{
			case 0: break;
			case 2: CastSkillAt(usehand); break;
			case 3:	CastSkillAt(usehand,x);break;
			case 4: CastSkillAt(usehand,x,y); break;
		}
        delay(50);
		var i = 1;
		while(me.mode == 10 || me.mode == 18 || me.mode == 7 || me.mode == 8 ) {
			delay(20);
			if ( (i++)%5 == 0 )
				CheckMe();
		};
		return true;
	} else return false;
}

function PreModeWait()
{
	for (var qw = 1; qw <= 20; qw++)
	{
		if (me.mode==7 || me.mode==8 || (me.mode>9 && me.mode<19)) return me.mode;
		delay(20);
	}
	return 10;
}


//**Item Functions
function MyGold()
{
	return me.getStat(14)+me.getStat(15);
}


//**Other Functions
function DoDelLocal(amount)
{
	if (me.ping>1000) amount = amount+rnd(0,10)+parseInt(me.ping/3-100);
	else if (me.ping >150) amount = amount+rnd(0,10)+parseInt(me.ping/2-50);
	else amount = amount+rnd(0,10)+me.ping;
	for ( ; amount > 200 ; amount -= 200 ) {
		if ( CheckMe )
	        	CheckMe();
        	delay( 200 );
	};
	delay( amount );
}
DoDel = DoDelLocal; // override BMpwnIt

// mode safe method because it calls CheckMe
function BM_TeleItemLocal(item)
{
	if(BMpwnItVersion==1.66 && ((rnd(1,100)>useTeleItem && me.getSkill(0)!="Telekinesis") || !me.getSkill("Telekinesis") || me.mp<20 || calcrange(item.x,item.y)>BM_MaxTkRange || calcrange(item.x,item.y)<BM_MinTkRange))return false;
	return DoCast( "Telekinesis", 0, item );
};
BM_TeleItem = BM_TeleItemLocal; // override BMpwnIt



function Abort()
{
  LogSave( 0 );
  quit();
}

function quitmessage(message)
{

	print("ÿc1::ÿc@" + message);
	bprint("Aborting game...");
	DoDel(2000);
	quit();
}

//----------------------------------------------------------------------------
// callback from Shrine Lib to goto to coord x,y
function DaeShrineMove( x, y ) {
    Teleport( x, y, 5, 3 );
}

//----------------------------------------------------------------------------
function Sh_FollowPathToThing2(path, x, y)
{
   var _delta = 40;             // was DeltaTeleport
   var deadlock = 0;
   var i = 1; //v0.27 no need to teleport on self ;)
   var t1 = 0, t2 = 0, t3 = 0;
   TeleportDeadlock = 5; // => think it is enough because Teleport can do long teleport

    while (i < path.length && myDist(x, y) > _delta)
    {
        oldx = me.x;
        oldy = me.y;

        if (deadlock > TeleportDeadlock)
        {
          dprint("Deadlock teleporting to destination...aborting...");
          return false;
        }

        Teleport( path[i][0], path[i][1], 5, 1 );
        t1++;
        if ( ( myDist(oldx, oldy) < 5 ) )
        {
            TeleportRandomly2();
            t3++;
        };

        if (myDist(path[i][0], path[i][1]) < 20)
        {
//            if ( sets["use_shrine"] )
//                ShrineLib_CheckForShrines(DaeShrineMove);
			CheckObjects( true, DaeShrineMove );
            ++i;
            deadlock = 0;
        }
        else
            deadlock++;
   }
/*v0.32
   bprint("We have arrived near 0x" + x.toString(16) + ", 0x" +
          y.toString(16));
   bprint("We took " + t1 + " path hop" + (t1 != 1 ? "s" : "") + ", " + t2 +
          " direct hop" + (t2 !=
                           1 ? "s" : "") + ", and " + t3 + " random hop" +
          (t3 != 1 ? "s" : "") + ".");
*/
   return true;
}

function TeleportRandomly2()
{
   Teleport(  me.x + Math.floor(40 * (rnd(0, 1) * 2 - 1)),
              me.y + Math.floor(40 * (rnd(0, 1) * 2 - 1)), 10, 1); //v0.26 change teleportto to Teleport
   DoDel(5);
}

//-----------------Kill Bosses----------------

//Shenk
function GotoShenk()
{
	if ( !Town.InTown() && ( ( me.area != 111 ) || myDist(shenk_path[0][0],shenk_path[0][1])>30 ) )
    	{
      		UseTP();
      		InTown();
    	};

    if ( Town.InTown() )
	    if (!Town.TakeWP( 5, 2 )) return false;
	    CleanUpMe(20);


	PreSkill(bossshenk);
	ShowState("Moving to Shenk");

	if (me.classid==1) ShrineMoveFunc=DaeShrineMove;
	else ShrineMoveFunc=BarbShrineMove;

	for (var i=0 ;i < 6 ;i++)
	{
		//CheckObjects( true, ShrineMoveFunc );
		if ((i<=3 && me.classid==0) || (i<=4 && me.classid==4)) 
			CleanUpMe(20);
		DoDel(300);
		if (i==4 && me.classid==4) 
			InitMap();
		MoveTo(shenk_path[i][0],shenk_path[i][1],true);
		DoDel(20);
		
	}
	if (getUnit(1,"Shenk the Overseer") && me.area==110) return true;
}


//Dac Farren
function GotoDac()
{
	
	if ( !Town.InTown() && (me.area!=110) )
	{
   		UseTP();
   		InTown();
   	};

   	if ( Town.InTown() ) if (!Town.TakeWP( 5, 2 )) return false;

	PreSkill(bossdac);
	ShowState("Moving to Dac Farren");
	DoDel(100);

	if (me.area==111) //highland
	{

		if (sets["shenk_when_dac_farren"])
			if (DoBoss(bossshenk.GotoBoss,bossshenk)) bossshenk.quest=false;

		//find path to foothill
		MoveTo(shenk_path[0][0],shenk_path[0][1],1);
		DoDel(15);
		MoveTo(shenk_path[1][0],shenk_path[1][1],1);
		DoDel(15);
		CheckObjects( true, DaeShrineMove );
	}

	if(me.classid==4 || me.classid==0)
	{
		var databack=new Object();
		databack["bossname"]=bossdac.lodname;
		databack["bossdist"]=20;
	}

	if (me.area==110) //foothill
	{
		if (me.classid==1)
			return GotoRoom2( 871, 871, 20, 80 );
		else
			return GotoRoom(871,871,20,7,databack);
	}

    return false;
}

//Eldritch

function GotoEld()
{
	if ( !Town.InTown() && ( me.area != 111 ) && ( me.area != 110 ) )
	{
      		UseTP();
      		InTown();
    	};

    	if (!Town.InTown() && myDist(shenk_path[6][0],shenk_path[6][1])>100 && sets["quest_dac"])
    	{
    		UseTP();
    		InTown();
    	}

	if ( Town.InTown() )
	  if (!Town.TakeWP( 5, 2 )) return false;

	ShowState("Moving to Eldritch");
	if (me.area == 110) // moving from shenk
	{
		for (var i=0;i<5;i++)
		{
			MoveTo(eld_path[i][0],eld_path[i][1]);
			DoDel(15);
		}
	}
	PreSkill(bosseld);
	ShowState("Moving to Eldritch");

	//Move from waypoint to eldrith
	return SubGotoEld();
}

//=========================================
//            Hephasto Code
//=========================================
function GotoHephasto()
{
	if (!Town.InTown())
	{
		UseTP();
		InTown();
	}

	if (Town.InTown())
		if (!Town.TakeWP(4,3)) return false;

	PreSkill(bosshephasto);

	delay(500);
	ShowState("Moving to Hephasto");

	var databack=new Object();
	databack["bossname"]="Hephasto The Armorer";
	databack["bossdist"]=10;

	if (me.classid==1) return GotoRoom2(853,854,20,80);
	else return GotoRoom(853,854,20,7,databack);
}

//Sharptooth in 1.10
function GotoSharp() {
	if ( !Town.InTown() && ( me.area != 111 ) ) {
      UseTP();
      InTown();
    };

	if ( Town.InTown() )
	  if (!Town.TakeWP( 5, 2 )) return false;

	PreSkill(bossthresh);

	delay(1000);
	ShowState("Moving to Sharptooth");

	if (me.classid >1) return GotoSharpBarb();
	else if (me.classid==1) return GotoSharp2();
};

function GotoSharp2()
{
	//Use Sh_PathFinding
    DebugWrite("Ask a sorted list of room" );
    var list = GetListRoomSorted( 931, 938 );
    DebugWrite("Get a sorted list with "+list.length+" points" );

    var binit = false;
    for ( var i = 0 ; i < list.length ; i++ ) {
        var tsw = list[i];
        if (tsw)
        {
            if ( !binit ) {
              Sh_BuildOpenMap(tsw.data, 20); // ShLib need this call
              DebugWrite( "Sh_BuildOpenMap finished");
              binit = true;
            };

            var path = Sh_FindPath(tsw.x, tsw.y, 80);
            DebugWrite( "Sh_FindPath finished");
            Sh_FollowPathToThingEx(path, tsw.x, tsw.y,80); //yy
            DebugWrite( "Sh_FollowPathToThing2 finished");
            DoDel(30);
            TeleportToStairs(tsw.x, tsw.y);

            for (var k=0;k<3;k++)
            {
                var ts=getUnit(1, bosssharp.lodname );
                if (ts)
                {
                    bprint("Sharptooth detected!");
                    return true;
                };
               ShowState("Looking for Sharptooth");
               delay(100);
			   CheckMe();
            }
        }
    };
    return false;
}

function sortcoord( a, b ) {
  if ( Dist2( a.x, a.y, me.x, me.y ) > Dist2( b.x, b.y, me.x, me.y ) )
    return 1;
  else
    return -1;
}

function GetListRoomSorted( lo, hi ) {
	var room=getRoom();
    var list = new Array();

	do
	{
		if ( room && ( room.number >= lo ) && ( room.number <= hi ) )
		{
            var tx = new Object();
            tx.x = room.x*5+20;
            tx.y = room.y*5+20;
            tx.data = room.number;
            list[ list.length ] = tx;
		}
	}while (room && room.getNext());

    DebugWrite("Has builded list with "+list.length+" points" );

    list.sort( sortcoord );
    return list;
}

//============================================================
// pathfind routine take from scavenger (again :D )
// modified in 0.42 faster code + checkme
function TakeStairs(lo, hi, area)
{
	var tile = GetStairs(lo, hi, area);
	if (!tile) {
		bprint("No tile found with classid: "+lo + "-"+hi);
		return false;
	}

	var a = me.area;
	var retry = 0;

	do {
	    if ( retry%3==0 )
			MoveTo(tile.x,tile.y);
		//ClickMap(tile.x,tile.y);
		for ( var retry2 = 0 ; Dist2( tile.x, tile.y ) > 9 && ( retry2 < 10 ) ; retry2++ ) {
			delay( 100 );
			CheckMe();
		};
		ClickMap(tile);
		//me.overhead("I've Clicked");
		for ( var retry2 = 0 ; a == me.area && ( retry2 < 10 ) ; retry2++ ) {
			delay( 100 );
			CheckMe();
		};
	}while(a == me.area && retry++ < 10 );

	if (a == me.area) {
		DebugWrite(" * ERROR: Failed to take stairs");
		return false;
	}

	delay( 500 ); // give some time
	return true;
}

function GetStairs(lo,hi,area)
{
	var tile = getUnit(5);
	do {
		if (tile && tile.classid >= lo && tile.classid <= hi){
			if ( !area || tile.area == area )
				return tile;
		}
	}while (tile && tile.getNext());

	return null;
}

function TeleportToStairs(x, y) {
    KillAllNearUniqueBoss();

    if ( myDist(x, y) > 15 ) //v0.33
  	   return Teleport(x, y, 15, 2 ); // v0.27
    else
       return true;
}

//============================================================
// Eyeback Code
//============================================================
function GotoEye()
{
	
    // always begin Eye from town
	if ( !Town.InTown() ) {
      UseTP();
      InTown();
    };

	if (!Town.TakeWP( 5, 3 )) return false;

	PreSkill(bosseye);

	ShowState("Moving to Eyeback");

	delay(1500);


	//GotoRoom(907,908,30,0);
	if (me.classid==1)
	{
		var ts=Sh_BuildMap(907,908,30);
		var path = Sh_FindPath(ts.x, ts.y, 80);
		Sh_FollowPathToThingEx(path, ts.x, ts.y,0); //yy
		TeleportToStairs(ts.x,ts.y);
	}
	else if(me.classid==4 || me.classid==0)
	{
		InitMap();
		var databack=new Object();
		databack["bossname"] = bosssharp.lodname;
		databack["bossdist"]=15;
		var path = cMap.FindPathToLevel( 111, me.x, me.y,7, mlREDUCEWALK, mlASTAR, mlFHMANHATTAN, 1.8 );
		cMap.PathMove( path,databack, 0, 7, mlASTAR )
	}

	return true;
}

//===========================================================
// Izual Code by Killkeeper(Aug-29)
//===========================================================
function GotoIzual()
{
	if (!Town.InTown()) {
		UseTP();
		InTown();
	}

	Town.MoveTo("exit",4);
	DoDel(500);
	walkto(5168,5089);

	if (me.area!=104) return false;

	if (me.classid==1)
	{
		InitMap();
		var path = cMap.FindPathToLevel( 105, me.x, me.y,20, mlREDUCESORC );
		cMap.PathMove( path,true, 0, 20, mlASTAR );

		if (!GotoRoom2(822,822,20,80)) return false;
	}
	else
	{
		InitMap();
		var databack=new Object();
		databack["bossname"] = bossizual.lodname;
		databack["bossdist"]=8;
		var path = cMap.FindPathToLevel( 105, me.x, me.y,7, mlREDUCEWALK, mlASTAR, mlFHMANHATTAN, 1.8 );
		cMap.PathMove( path,true, 0, 7, mlASTAR );

		bprint("Now pathfinding to Izual");
		DoDel(500);
		InitMap();
		if (!GotoRoom(822,822,20,7,databack)) return false;
	}
	return true;
}

//============================================================
// Andariel Code(some code taken from scavenger's Multi-MF bot)
//============================================================

function GotoAndariel()
{
	//DebugWrite("Going to Andariel");
	
	if (!Town.InTown())
	{
		UseTP();
		InTown();
	}
	
	if (!Town.TakeWP(1,9)) {
	//	DebugWrite(" * ERROR: Failed to take tp to catacombs lvl 2");
		return false;
	}
	
	PreSkill(bossandy);
	DoDel(100);
	
	if (me.classid==1)
	{
		if (!GotoRoom2(291, 294, 20, 50)) {
			//DebugWrite(" * ERROR: GotoRoom failed in catacombs lvl 2");
			return false;
		}
		if (!TakeStairs(18,18)) {
			return false;
		}
		if (!GotoRoom2(291, 294, 20, 50)) {
			//DebugWrite(" * ERROR: GotoRoom failed in catacombs lvl3");
			return false;
		}
		TakeStairs(18,18);
		
		Teleport(22582, 9595, 5, 5);	
		Teleport(22560, 9582, 5, 5);
		Teleport(22547, 9565, 5, 5);
		return true;
	}
	else
	{
		var databack=new Object();
		databack["bossname"]=bossandy.lodname;
		databack["bossdist"]=7;
		
		if (!GotoRoom(291,294,20,7,true)) return false;
		if (!TakeStairs(18,18)) return false;
		if (!GotoRoom(291,294,20,7,true)) return false;
		if (!TakeStairs(18,18)) return false;
		if (!GotoToDest(22551,9553,databack,7)) return false;
		
		return true;
	}
	
	
	return false;
}

//============================================================
// SNAPCHIP Code
//============================================================
function GotoSnapChip()
{
    if ( !Town.InTown() ) {
        UseTP();
        InTown();
    };

	//Use Sh_PathFinding
	
    if ( !GotoIceDown() )
      return false;

    // time to clean the entrance
    KillSnapChipEntrance();

    // enter in ice
    if ( !TakeStairs(75,75) )
      return false;

    if ( !SearchSnapChip() )
      return false;

    return true;
}

function GotoIceDown()
{
    // take the wp
  	if (!Town.TakeWP(5, 8)) return false;

  	PreSkill(bosssnap);

    if (me.classid==1)
    {
	    DebugWrite( "Search after the entrance" );
	    var ts=Sh_BuildMap(1026,1029,20);
	    if ( !ts )
	      return false;

	    DebugWrite( "Finded entrance, search a path" );
		var path = Sh_FindPath(ts.x, ts.y, 50);
	    if ( !path )
	      return false;

	    DebugWrite( "Finded path, go" );
	    if ( !Sh_FollowPathToThingEx(path, ts.x, ts.y,50) )
	      return false;

	    DebugWrite( "Arrived but need more close" );
		if ( !TeleportToStairs(ts.x,ts.y) )
	      return false;

	    DebugWrite( "Arrived" );
	    return true;
    }
    else
    {
    	GotoRoom(1026,1029,20,7,true);
    }

    DebugWrite( "Arrived but need more close" );
	//mlMap is enough strong to guide our bot to a correct place!
	//if ( !TeleportToStairs(ts.x,ts.y) )
      //return false;

    DebugWrite( "Arrived" );
    return true;
}

var cMap=null;

function SearchSnapChip()
{
   //bprint("Now start to search snapchip");
   // do all room in the level
   var destx = new Array();
   var desty = new Array();
   destx[0] = 10140;
   desty[0] = 11885;
   destx[1] = 10120;
   desty[1] = 12000;
   destx[2] = 10040;
   desty[2] = 12020;
   destx[3] = 10040;
   desty[3] = 11900;

   if (me.classid==1)
   {
	   for ( var i = 0 ; i < 4 ; i++ )
	   {
	      if ( myDist( destx[i], desty[i] ) > 40 ) {
	          var path = Sh_FindPath(destx[i], desty[i], 80);
	          if ( path )
	             if ( Sh_FollowPathToThingEx(path, destx[i], desty[i],0) ) // no repath for snap
	                Teleport(destx[i],desty[i],10);
	      }
	      else
	         Teleport(destx[i],desty[i],10);

	   	  var boss = getUnit(1,sets["name_snapchip"]);
	      if ( boss )
	        return true;
	   };
   }
   else
   {
   	for (var i=0;i<4;i++)
   	{
   		InitMap();
   		var databack=new Object();
   		databack["bossname"]=bosssnap.lodname;
   		databack["bossdist"]=15;
   		var path=cMap.FindPath(me.x, me.y, destx[i], desty[i], 7, mlREDUCEWALK, mlASTAR, mlFHMANHATTAN, 1.8);
   		cMap.PathMove(path,databack,0,7,mlASTAR);

   		var boss = getUnit(1,bosssnap.lodname);
   		if (boss) return true;
   	}

   }
   return false;
}

function KillSnapChipEntrance()
{
    if (!sets["cleanup_icy_entries"]) return true;
    var nennemies = 0;
    var monster;
    var sthkilled = false;

    var tile = GetStairs(75, 75);
    if (!tile) return false;

    if (me.classid==1)
    	Teleport( tile.x, tile.y, 5 );
    else
    	MoveTo(tile.x,tile.y,1);

    do {
      monster = FindEnemyNear( me, 20 );
      if ( monster ) {
         sthkilled = KillMonster( monster, 30 );
         nennemies++;
      };
    } while ( monster && ( nennemies < 3 ) );

    if ( sthkilled )
        Pick();
        //bprint("KillSnapChipEntrance done");
}


//============================================================
// Pindle Code
//============================================================
function GotoPindle()
{
	
    // always begin pindle in town
	if ( !Town.InTown() ) {
      UseTP();
      InTown();
    };

    if ( me.area != 109 ) // town but not harrogath
  	    if (!Town.TakeWP(5, 1)) return false;

	if (!sets["use_wp_pindle"])
	{
		if (sets["shop_anya"] && (!anyashopped) && MyGold() >= sets["mingoldshop"] )
		{
			DoShop( "anya", Sc_MonsterClassID_Anya, true, true );
		}

		if (sets["gamble"] && MyGold() >= sets["mingoldgamble"])
		{
			for(i=0;i<sets["max_gamble_one_run"] && MyGold() >= sets["mingoldgamble"];i++)
			{
				var npc=GoGamble();
				if (npc)
				{
					var gidlist = GambleIt(npc.name,npc);

					var retries=0;
					while(retries++<5 && getUIFlag(0x08))
					{
						me.cancel(1);
						//npc.cancel(1);
						delay(500);
					}
					if (getUIFlag(0x08)) me.cancel(1);

					if (gidlist && gidlist.length)
					{
						item=getUnit(4,null,100);
						if (item) do
						{
							for(i=0;i<gidlist.length;i++)
							{
								var nowgid=gidlist[i];
								if (item.gid==nowgid) Town.StashItem(item);
							}
						}while(item && item.getNext())
					}
				}
			}
		}

		if ( !Town.MoveTo("portal",5) )
	        return false;

		DoDel(10);
		if (me.classid==0) PreSkill();
		if (!ChangeArea("Portal",121))
	        return false;
		//kaka,into portal!
		DoDel(100);
		if (me.classid!=0) PreSkill(bosspindle);
		ShowState("Moving to Pindleskin");

		if ( me.classid == 1 ) {
			MoveTo(pindle_path[0][0],pindle_path[0][1]);
			DoDel(15);
			MoveTo(pindle_path[1][0],pindle_path[1][1]);
			DoDel(15);
		}
		else {
			var databack = new Array();
			databack["bossname"] = bosspindle.lodname;
			if ( GotoToDest( pindle_path[pindle_path.length-1][0], pindle_path[pindle_path.length-1][1], databack ) )
				return true;
		};
	}
	else
	{
		if (!Town.TakeWP(5,6)) return false;
		PreSkill(bosspindle);
		if (!GotoToDest(10194,14897,20,50,50)) return false;
		if (!TakeStairs(78,78)) return false;

		if (me.area!=122) return false;

		if (!GotoToDest(10193,13997,20,50,50)) return false;
		if (!TakeStairs(78,78)) return false;

		if (me.area!=121) return false;

		return true;
	}


//v0.28 => to restrictive, our algorithm are good, no boss can escape our power :D
//if (Math.abs(me.x - pindle_path[1][0]) < 4 && Math.abs(me.y - pindle_path[1][1]) < 4) return true;

    for ( var i = 0 ; i < 4 ; i++ )
    {
   	  var boss = getUnit(1,bosspindle.lodname);
      if ( boss )
        return true;
      DoDel( 100 );
    };
    return false;
}

function PindleBack()
{
    MoveTo(10059,13234);
    DoDel(15);
    MoveTo(10063,13276);
    DoDel(15);

    portal=getUnit(2,"Portal");
    if (portal)
    {
        MoveTo(portal.x,portal.y);
        DoDel(15);
        return ChangeArea2("Portal",108);
    }
}

//============================================================
// Bonesaw Breaker Code
//============================================================
function GotoBone()
{
    if ( !Town.InTown() ) {
        UseTP();
        InTown();
    };

  	if (!Town.TakeWP(5, 5)) return false;

	//Use Sh_PathFinding
	
  	PreSkill(bossbone);

	return SubGotoBone();
}


//========================================================

//============================================================
//                  Stormtree Code
//============================================================

function GotoStorm()
{
	if ( !Town.InTown() ) {
        	UseTP();
        	InTown();
    	};

	if (!Town.TakeWP(3,5)) return false;

	PreSkill(bossstorm);

	if (me.classid==1)
	{
		//
		if (!GotoRoom2(614, 614, 20, 80)) return false;
	}
	else
	{
		var databack=new Object();
		databack["bossname"] = bossstorm.lodname;
		databack["bossdist"]=15;
		InitMap();
		var path = cMap.FindPathToLevel( 78, me.x, me.y,10, mlREDUCEWALK, mlASTAR, mlFHMANHATTAN, 1.8 );
		cMap.PathMove( path,databack, 0, 10, mlASTAR )
	}

    for ( var i = 0 ; i < 4 ; i++ )
    {
   	  var boss = getUnit(1,bossstorm.lodname);
      if ( boss )
        return true;
      DoDel( 100 );
    };
    return false;
}

//========================================================


function Pick( override_snag_delay )
{
	var strItem;
	ShowState("Picking items");
	if ( !override_snag_delay )
		override_snag_delay = sets["snag_delay"];

    for ( var i = 0 ; i < override_snag_delay/100 ; i++ ) {
        CheckMe();
        delay( 100 );
    };
	snagrad = sets["snag_rad"];
        mingoldpickup = sets["mingoldpickup"];

	if (BMpwnItVersion>=1.65 && sets["snag_stash_maxtimes"] >= 1)
	{
		for(var stashtimes=0; stashtimes < sets["snag_stash_maxtimes"]; stashtimes++){
			var reval=SnagIt(sets["snag_ini"]);
			if ((reval & 1)) bprint("Couldn't pick up items!");
			if ((reval & 2 ) && sets["snag_stash"])
			{
				bprint("Not enough place,need to stash your item first");
				BackToTown();
				if ( !override_snag_delay )
				override_snag_delay = sets["snag_delay"];
		                for ( var i = 0 ; i < override_snag_delay/100 ; i++ ) {
				      CheckMe();
				      delay( 20 );
				};
				continue;
			}
			else break;
		}
		if ((reval & 4 ))
			bprint("At least an item is out of range!");
	}
	else
		SnagIt(sets["snag_ini"]);
}

//Logging

function Initlistboss() {
  if ( me.classid == 4 ) {
	if ( sets["shrineMaxDistance"] > 15 )
		sets["shrineMaxDistance"] = 15;
	if (sets["chest_hall_dist"]>6)
		sets["chest_hall_dist"]=6;
	if (sets["chest_openair_dist"]>14)
		sets["chest_openair_dist"]=14;
	if (sets["chest_cave_dist"]>8)
		sets["chest_cave_dist"]=8;
	if (sets["chest_tower_dist"]>8)
		sets["chest_tower_dist"]=8;		
	if (sets["chest_catacombs_dist"]>4)
		sets["chest_catacombs_dist"]=4;
	
	sets["tpafterpindle"]=true;

	character["primary_skill"] = skill_global["barb_primary_skill"];
	character["secondary_skill"] = skill_global["barb_secondary_skill"];
	character["backup_skill"] = skill_global["barb_backup_skill"];
	//sets["quest_ancient"]=false;
  	sets["quest_mausoleum"]=false;
  }
  if (me.classid == 0 )
  {
	sets["quest_eyeback"]=false;		//set 'true' to kill Eyeback
	sets["quest_sharp"]=false;		//set 'true' to kill SharpTooth
	sets["quest_dac"]=false;			//set 'true' to kill Dac Farren
	sets["quest_thresh"]=false;		//set 'true' to kill Thresh Socket
	sets["quest_snapchip"]=false;		//set 'true' to kill Snapchip Shatter
	sets["quest_bone"]=false;		//set 'true' to kill Bonesaw Breaker
	sets["quest_froz"]=false;		//set 'true' to kill Frozenstein (be carefull, it is the harder boss in the list)
	//sets["quest_countess"]=false;		//set 'true' to kill The countess
	sets["quest_meph"]=false;		//set 'true' to kill Mephisto
	sets["quest_storm"]=false;		//set 'true' to kill Stormtree
	sets["quest_baal"]=false;		//set 'true' to kill Baal (be carefull, it is the final boss act 5), sure that your perso can kill this superboss)
	sets["quest_nihlathak"]=false;		//set 'true' to kill Nihlathak (be carefull, it is a boss with corpse explosion)
	sets["quest_hephasto"]=false;		//set 'true' to kill Hephasto(be careful,this guy is awesome)
	sets["quest_tristram"]=false;		//set 'true' to visit all our friends at Tristram + Rakanishu
	sets["quest_creeping"]=false;		//set 'true' to kill Creeping Feature in Stony Tomb Level 2 (2nd Act)
	sets["quest_council"]=false;		//set 'true' to kill Council in Travincal (act 3)
	sets["quest_izual"]=false;		//set 'true' to kill Izual
	sets["quest_andy"]=false;	//set 'true' to kill the sister Andariel!
	sets["quest_cows"]=false;	     //set true to visit Moo Moo Farm
	//sets["quest_ancient"]=false;
	sets["quest_mausoleum"]=false;
  };
  if (me.classid == 3)
  {
	sets["quest_eyeback"]=false;		//set 'true' to kill Eyeback
	sets["quest_sharp"]=false;		//set 'true' to kill SharpTooth
	sets["quest_dac"]=false;			//set 'true' to kill Dac Farren
	sets["quest_thresh"]=false;		//set 'true' to kill Thresh Socket
	sets["quest_snapchip"]=false;		//set 'true' to kill Snapchip Shatter
	sets["quest_bone"]=false;		//set 'true' to kill Bonesaw Breaker
	sets["quest_froz"]=false;		//set 'true' to kill Frozenstein (be carefull, it is the harder boss in the list)
	//sets["quest_countess"]=false;		//set 'true' to kill The countess
	sets["quest_meph"]=false;		//set 'true' to kill Mephisto
	sets["quest_storm"]=false;		//set 'true' to kill Stormtree
	sets["quest_baal"]=false;		//set 'true' to kill Baal (be carefull, it is the final boss act 5), sure that your perso can kill this superboss)
	sets["quest_nihlathak"]=false;		//set 'true' to kill Nihlathak (be carefull, it is a boss with corpse explosion)
	sets["quest_hephasto"]=false;		//set 'true' to kill Hephasto(be careful,this guy is awesome)
	sets["quest_tristram"]=false;		//set 'true' to visit all our friends at Tristram + Rakanishu
	sets["quest_creeping"]=false;		//set 'true' to kill Creeping Feature in Stony Tomb Level 2 (2nd Act)
	sets["quest_council"]=false;		//set 'true' to kill Council in Travincal (act 3)
	sets["quest_izual"]=false;		//set 'true' to kill Izual
	//sets["quest_andy"]=false;	//set 'true' to kill the sister Andariel!
	sets["quest_cows"]=false;	     //set true to visit Moo Moo Farm
	//sets["quest_ancient"]=false;
	sets["quest_mausoleum"]=false;
  };
  if ( sets["d2_classic"] ) {
	sets["quest_pindle"]=false;
	sets["quest_eyeback"]=false;
	sets["quest_sharp"]=false;
	sets["quest_shenk"]=false;
	sets["quest_dac"]=false;
	sets["quest_eld"]=false;
	sets["quest_thresh"]=false;
	sets["quest_snapchip"]=false;
	sets["quest_bone"]=false;
	sets["quest_froz"]=false;
	sets["quest_nihlathak"]=false;
  };
  if (sets["quest_nihlathak"] && sets["quest_pindle"] && (sets["use_wp_pindle"] != sets["use_wp_nihlathak"]) ) {
  	bprint( "You ask to kill nihlathak and pindle in different ways, it is impossible" );
  	bprint( "Nihlathak is disabled" );
	sets["quest_nihlathak"] = false;
  };

  bosspindle = new Object();
  bosspindle.name = "PindleSkin";
  bosspindle.questname = "pindle";
  bosspindle.lodname = sets["name_pindle"];
  bosspindle.maxattacks = sets["attack_pindle"];
  bosspindle.mindist = sets["attack_pindle"][2];
  bosspindle.esc = esc_pindle;
  bosspindle.quest = sets["quest_pindle"];
  bosspindle.skill = skill_pindle;
  bosspindle.pathbeforeattack = false;
  bosspindle.kill_minions = sets["kill_minions"];
  bosspindle.kill_nearboss = false;
  bosspindle.classid = 440;
  bosspindle.bFindItem = true;
  bosspindle.GotoBoss = GotoPindle;
  bosspindle.selected = false;
  bosspindle.freepositioncheck=true;
  listboss[0] = bosspindle;

  bosseye = new Object();
  bosseye.name = "Eyeback";
  bosseye.questname = "eyeback";
  bosseye.lodname = sets["name_eyeback"];
  bosseye.maxattacks = sets["attack_eyeback"];
  bosseye.mindist = sets["attack_eyeback"][2];
  bosseye.esc = esc_eyeback;
  bosseye.quest = sets["quest_eyeback"];
  bosseye.skill = skill_eyeback;
  bosseye.pathbeforeattack = true;
  bosseye.kill_minions = sets["kill_minions"];
  bosseye.kill_nearboss = true;
  bosseye.classid = 529;
  bosseye.bFindItem = true;
  bosseye.GotoBoss = GotoEye;
  bosseye.selected = false;
  bosseye.freepositioncheck=false;
  listboss[1] = bosseye;

  bosssharp = new Object();
  bosssharp.name = "Sharptooth";
  bosssharp.questname = "sharp";
  bosssharp.lodname = sets["name_sharp"];
  bosssharp.maxattacks = sets["attack_sharp"];
  bosssharp.mindist = sets["attack_sharp"][2];
  bosssharp.esc = esc_sharp;
  bosssharp.quest = sets["quest_sharp"];
  bosssharp.skill = skill_sharp;
  bosssharp.pathbeforeattack = true;
  bosssharp.kill_minions = sets["kill_minions"];
  bosssharp.kill_nearboss = true;
  bosssharp.classid = 481;
  bosssharp.bFindItem = true;
  bosssharp.GotoBoss = GotoSharp;
  bosssharp.selected = false;
  bosssharp.freepositioncheck=false;
  listboss[2] = bosssharp;

  bossshenk = new Object();
  bossshenk.name = "Shenk";
  bossshenk.questname = "shenk";
  bossshenk.lodname = sets["name_shenk"];
  bossshenk.maxattacks = sets["attack_shenk"];
  bossshenk.mindist = sets["attack_shenk"][2];
  bossshenk.esc = esc_shenk;
  bossshenk.quest = sets["quest_shenk"];
  bossshenk.skill = skill_shenk;
  bossshenk.pathbeforeattack = false;
  if ( sets["minion_shenk"] )
    bossshenk.killfunc = KillShenk;
  bossshenk.kill_minions = false; // minions die when shenk dies
  bossshenk.kill_nearboss = false;
  bossshenk.classid = 0;
  bossshenk.bFindItem = false;
  bossshenk.GotoBoss = GotoShenk;
  bossshenk.selected = false;
  bossshenk.freepositioncheck=false;
  listboss[3]= bossshenk;

  bossdac = new Object();
  bossdac.name = "Dac Farren";
  bossdac.questname = "dac";
  bossdac.lodname = sets["name_dac"];
  bossdac.maxattacks = sets["attack_dac"];
  bossdac.mindist = sets["attack_dac"][2];
  bossdac.esc = esc_dac;
  bossdac.quest = sets["quest_dac"];
  bossdac.skill = skill_dac;
  bossdac.pathbeforeattack = false;
  bossdac.checkchest = false;
  bossdac.kill_minions = sets["kill_minions"];
  bossdac.kill_nearboss = false;
  bossdac.classid = 494;
  bossdac.bFindItem = true;
  bossdac.GotoBoss = GotoDac;
  bossdac.selected = false;
  bossdac.freepositioncheck=false;
  listboss[4] = bossdac;

  bosseld = new Object();
  bosseld.name = "Eldritch";
  bosseld.questname = "eld";
  bosseld.lodname = sets["name_eld"];
  bosseld.maxattacks = sets["attack_eld"];
  bosseld.mindist = sets["attack_eld"][2];
  bosseld.esc = esc_eld;
  bosseld.quest = sets["quest_eld"];
  bosseld.skill = skill_eld;
  bosseld.pathbeforeattack = false;
  bosseld.kill_minions = sets["kill_minions"];
  bosseld.kill_nearboss = true;
  bosseld.classid = 453;
  bosseld.bFindItem = true;
  bosseld.GotoBoss = GotoEld;
  bosseld.selected = false;
  bosseld.freepositioncheck=false;
  listboss[5] = bosseld;

  bossthresh = new Object();
  bossthresh.name = "Thresh";
  bossthresh.questname = "thresh";
  bossthresh.lodname = sets["name_thresh"];
  bossthresh.maxattacks = sets["attack_thresh"];
  bossthresh.mindist = sets["attack_thresh"][2];
  bossthresh.esc = esc_thresh;
  bossthresh.quest = sets["quest_thresh"];
  bossthresh.skill = skill_thresh;
  bossthresh.pathbeforeattack = true;
  bossthresh.kill_minions = false; // thresh has minions ??
  bossthresh.kill_nearboss = true;
  bossthresh.classid = 0;
  bossthresh.bFindItem = true;
  bossthresh.GotoBoss = GotoThresh;
  bossthresh.selected = false;
  bossthresh.freepositioncheck=false;
  listboss[6] = bossthresh;

  bosssnap = new Object();
  bosssnap.name = "Snapchip";
  bosssnap.questname = "snapchip";
  bosssnap.lodname = sets["name_snapchip"];
  bosssnap.maxattacks = sets["attack_snapchip"];
  bosssnap.mindist = sets["attack_snapchip"][2];
  bosssnap.esc = esc_snapchip;
  bosssnap.quest = sets["quest_snapchip"];
  bosssnap.skill = skill_snapchip;
  bosssnap.pathbeforeattack = false; // 0.30 => changed to false (time is money)
  bosssnap.checkchest = true;
  bosssnap.kill_minions = sets["kill_minions"];
  bosssnap.kill_nearboss = true;
  bosssnap.classid = 501;
  bosssnap.bFindItem = true;
  bosssnap.GotoBoss = GotoSnapChip;
  bosssnap.selected = false;
  bosssnap.freepositioncheck=false;
  listboss[7] = bosssnap;

  bossbone = new Object();
  bossbone.name = "Bonesaw";
  bossbone.questname = "bone";
  bossbone.lodname = sets["name_bone"];
  bossbone.maxattacks = sets["attack_bone"];
  bossbone.mindist = sets["attack_bone"][2];
  bossbone.esc = esc_bone;
  bossbone.quest = sets["quest_bone"];
  bossbone.skill = skill_bone;
  bossbone.pathbeforeattack = false;
  bossbone.checkchest = true;
  bossbone.kill_minions = sets["kill_minions"];
  bossbone.kill_nearboss = true;
  bossbone.classid = 437;
  bossbone.bFindItem = true;
  bossbone.GotoBoss = GotoBone;
  bossbone.selected = false;
  bossbone.freepositioncheck=false;
  listboss[8] = bossbone;

  bossfroz = new Object();
  bossfroz.name = "Frozenstein";
  bossfroz.questname = "froz";
  bossfroz.lodname = sets["name_froz"];
  bossfroz.maxattacks = sets["attack_froz"];
  bossfroz.mindist = sets["attack_froz"][2];
  bossfroz.esc = esc_froz;
  bossfroz.quest = sets["quest_froz"];
  bossfroz.skill = skill_froz;
  bossfroz.pathbeforeattack = false;
  bossfroz.checkchest = false;
  bossfroz.kill_minions = sets["kill_minions"];
  bossfroz.kill_nearboss = true;
  bossfroz.classid = 449;
  bossfroz.bFindItem = true;
  bossfroz.GotoBoss = GotoFroz;
  bossfroz.selected = false;
  bossfroz.freepositioncheck=false;
  listboss[9] = bossfroz;

  bosscountess = new Object();
  bosscountess.name = "The Countess";
  bosscountess.questname = "countess";
  bosscountess.lodname = sets["name_countess"];
  bosscountess.maxattacks = sets["attack_countess"];
  bosscountess.mindist = sets["attack_countess"][2];
  bosscountess.esc = esc_countess;
  bosscountess.quest = sets["quest_countess"];
  bosscountess.skill = skill_countess;
  bosscountess.pathbeforeattack = false;
  bosscountess.checkchest = false;
  bosscountess.kill_minions = sets["kill_minions"];
  bosscountess.kill_nearboss = true;
  bosscountess.classid = 45;
  bosscountess.bFindItem = false;
  bosscountess.GotoBoss = GotoCountess;
  bosscountess.selected = false;
  bosscountess.freepositioncheck=false;
  listboss[10] = bosscountess;

  bossmeph = new Object();
  bossmeph.name = "Mephisto";
  bossmeph.questname = "meph";
  bossmeph.lodname = c_DaeClassID_Mephisto;
  bossmeph.maxattacks = sets["attack_meph"];
  bossmeph.mindist = sets["attack_unique"][2];
  bossmeph.esc = new Array();
  bossmeph.quest = sets["quest_meph"];
  bossmeph.skill = skill_meph;
  bossmeph.pathbeforeattack = false;
  bossmeph.checkchest = true;
  bossmeph.kill_minions = false; // no minions ;)
  bossmeph.kill_nearboss = false; // hum :rolleyes: can be dangerous
  bossmeph.classid = 0;
  bossmeph.bFindItem = false;
  bossmeph.GotoBoss = GotoMeph;
  bossmeph.selected = false;
  bossmeph.freepositioncheck=false;
  if (sets["safe_meph"] && me.classid==1) 
  {
     bossmeph.killfunc = KillMeph;
	 sets["dodge_missiles"]=false;
  }
  listboss[11] = bossmeph;

  bossstorm = new Object();
  bossstorm.name = "Stormtree";
  bossstorm.questname = "storm";
  bossstorm.lodname = sets["name_storm"];
  bossstorm.maxattacks = sets["attack_storm"];
  bossstorm.esc = esc_storm;
  bossstorm.quest = sets["quest_storm"];
  bossstorm.mindist = sets["attack_storm"][2];
  bossstorm.skill = skill_storm;
  bossstorm.pathbeforeattack = true;
  bossstorm.checkchest = false;
  bossstorm.kill_minions = sets["kill_minions"];
  bossstorm.kill_nearboss = true;
  bossstorm.classid = 129;
  bossstorm.bFindItem = true;
  bossstorm.GotoBoss = GotoStorm;
  bossstorm.selected = false;
  bossstorm.freepositioncheck=false;
  listboss[12] = bossstorm;

  bossbaal = new Object();
  bossbaal.name = "Baal";
  bossbaal.questname = "Baal";
  bossbaal.lodname = c_DaeClassID_Baal;
  bossbaal.maxattacks = sets["attack_baal"];
  bossbaal.mindist = sets["attack_baal"][2];
  bossbaal.esc = new Array();
  bossbaal.quest = sets["quest_baal"];
  bossbaal.skill = skill_baal;
  bossbaal.pathbeforeattack = true;
  bossbaal.killfunc = KillBaal;
  bossbaal.kill_minions = false; // minions die when shenk dies
  bossbaal.kill_nearboss = false;
  bossbaal.classid = 0;
  bossbaal.bFindItem = false;
  bossbaal.GotoBoss = GotoBaal;
  bossbaal.selected = false;
  bossbaal.freepositioncheck=false;
  listboss[13]= bossbaal;

  bossnihlathak = new Object();
  bossnihlathak.name = "Nihlathak";
  bossnihlathak.questname = "Nihlathak";
  bossnihlathak.lodname = c_DaeClassID_Nihlathak;
  bossnihlathak.maxattacks = sets["attack_nihlathak"];
  bossnihlathak.mindist = sets["attack_nihlathak"][2];
  bossnihlathak.esc = esc_nihlathak;
  bossnihlathak.quest = sets["quest_nihlathak"];
  bossnihlathak.skill = skill_nihlathak;
  bossnihlathak.pathbeforeattack = false;
  bossnihlathak.kill_minions = sets["kill_minions"];;
  bossnihlathak.kill_nearboss = true;
  bossnihlathak.classid = 458;
  bossnihlathak.bFindItem = false;
  bossnihlathak.GotoBoss = GotoNihlathak;
  bossnihlathak.selected = false;
  bossnihlathak.freepositioncheck=false;
  listboss[14]= bossnihlathak;

  bosshephasto = new Object();
  bosshephasto.name = "Hephasto";
  bosshephasto.questname = "Hephasto";
  bosshephasto.lodname = sets["name_hephasto"];
  bosshephasto.maxattacks = sets["attack_hephasto"];
  bosshephasto.esc = esc_hephasto;
  bosshephasto.quest = sets["quest_hephasto"];
  bosshephasto.mindist = sets["attack_hephasto"][2];
  bosshephasto.skill = skill_hephasto;
  bosshephasto.pathbeforeattack = true;
  bosshephasto.checkchest = false;
  bosshephasto.kill_minions = sets["kill_minions"];
  bosshephasto.kill_nearboss = true;
  bosshephasto.classid = 409;
  bosshephasto.bFindItem = true;
  bosshephasto.GotoBoss = GotoHephasto;
  bosshephasto.freepositioncheck=false;
  listboss[15] = bosshephasto;


  bosstristram = new Object();
  bosstristram.name = "Griswold and his friends";
  bosstristram.questname = "tristram";
  bosstristram.lodname = sets["name_tristram"];
  bosstristram.maxattacks = sets["attack_tristram"];
  bosstristram.esc = esc_tristram;
  bosstristram.quest = sets["quest_tristram"];
  bosstristram.mindist = sets["attack_tristram"][2];
  bosstristram.skill = skill_tristram;
  bosstristram.pathbeforeattack = true;
  bosstristram.checkchest = false;
  bosstristram.kill_minions = true;
  bosstristram.kill_nearboss = true;
  bosstristram.classid = 365;
  bosstristram.bFindItem = true;
  bosstristram.freepositioncheck=false;
  if ( me.classid == 1 )
  	bosstristram.GotoBoss = Gototristram;
  listboss[16] = bosstristram;


  bosscreeping = new Object();
  bosscreeping.name = "Creeping";
  bosscreeping.questname = "creeping";
  bosscreeping.lodname = sets["name_creeping"];
  bosscreeping.maxattacks = sets["attack_creeping"];
  bosscreeping.esc = esc_creeping;
  bosscreeping.quest = sets["quest_creeping"];
  bosscreeping.mindist = sets["attack_creeping"][2];
  bosscreeping.skill = skill_creeping;
  bosscreeping.pathbeforeattack = true;
  bosscreeping.checkchest = true;
  bosscreeping.kill_minions = true;
  bosscreeping.kill_nearboss = true;
  bosscreeping.classid = 97;
  bosscreeping.bFindItem = true;
  bosscreeping.freepositioncheck=false;
  //if ( me.classid == 1 )
  	bosscreeping.GotoBoss = Gotocreeping;
  listboss[17] = bosscreeping;


  bosscouncil = new Object();
  bosscouncil.name = "Council";
  bosscouncil.questname = "Council";
  bosscouncil.lodname = sets["name_council"];
  bosscouncil.maxattacks = sets["attack_council"];
  bosscouncil.esc = esc_council;
  bosscouncil.quest = sets["quest_council"];
  bosscouncil.mindist = sets["attack_council"][2];
  bosscouncil.skill = skill_council;
  bosscouncil.pathbeforeattack = true;
  bosscouncil.checkchest = true;
  bosscouncil.kill_minions = true;
  bosscouncil.kill_nearboss = true;
  bosscouncil.classid = 97;
  bosscouncil.bFindItem = true;
  bosscouncil.freepositioncheck=false;
  if ( me.classid == 1 )
  	bosscouncil.GotoBoss = Gotocouncil;
  listboss[18] = bosscouncil;


  bossizual = new Object();
  bossizual.name = "Izual";
  bossizual.questname = "Izual";
  bossizual.lodname = sets["name_izual"];
  bossizual.maxattacks = sets["attack_izual"];
  bossizual.esc = esc_izual;
  bossizual.quest = sets["quest_izual"];
  bossizual.mindist = sets["attack_izual"][2];
  bossizual.skill = skill_izual;
  bossizual.pathbeforeattack = true;
  bossizual.checkchest = false;
  bossizual.kill_minions = true;
  bossizual.kill_nearboss = true;
  bossizual.classid = 256;
  bossizual.bFindItem = true;
  bossizual.GotoBoss = GotoIzual;
  bossizual.freepositioncheck=false;
  listboss[19] = bossizual;

  bosscows = new Object();
  bosscows.name = "The Cow King";
  bosscows.questname = "The Moo Moo Farm";
  bosscows.lodname = sets["name_cows"];
  bosscows.maxattacks = sets["attack_cows"];
  bosscows.esc = esc_cows;
  bosscows.quest = sets["quest_cows"];
  bosscows.mindist = sets["attack_cows"][2];
  bosscows.skill = skill_cows;
  bosscows.pathbeforeattack = true;
  bosscows.checkchest = false;
  bosscows.kill_minions = true;
  bosscows.kill_nearboss = true;
  bosscows.classid = 256;
  bosscows.bFindItem = true;
  if (me.classid == 1) bosscows.GotoBoss = GotoCows;
  listboss[20] = bosscows;
  
  bossandy = new Object();
  bossandy.name = "Andariel";
  bossandy.questname = "Andariel";
  bossandy.lodname = sets["name_andy"];
  bossandy.maxattacks = sets["attack_andy"];
  bossandy.esc = esc_andy;
  bossandy.quest = sets["quest_andy"];
  bossandy.mindist = sets["attack_andy"][2];
  bossandy.skill = skill_andy;
  bossandy.pathbeforeattack = true;
  bossandy.checkchest = false;
  bossandy.kill_minions = true;
  bossandy.kill_nearboss = true;
  bossandy.classid = 256;
  bossandy.bFindItem = true;
  bossandy.GotoBoss = GotoAndariel;
  bossandy.freepositioncheck=false;
  listboss[21] = bossandy;

  bosspit = new Object();
  bosspit.name = "The Pit";
  bosspit.questname = "The Pit";
  bosspit.lodname = sets["name_pit"];
  bosspit.maxattacks = sets["attack_pit"];
  bosspit.esc = esc_pit;
  bosspit.quest = sets["quest_pit"];
  bosspit.mindist = sets["attack_pit"][2];
  bosspit.skill = skill_pit;
  bosspit.pathbeforeattack = true;
  bosspit.checkchest = false;
  bosspit.kill_minions = true;
  bosspit.kill_nearboss = true;
  bosspit.classid = -1;
  bosspit.bFindItem = false;
  bosspit.GotoBoss = GotoThePit;
  bosspit.killfunc = CleanThePit;
  bosspit.freepositioncheck=false;
  listboss[22] = bosspit;
  
  bossancient = new Object();
  bossancient.name = "Ancient Tunnel";
  bossancient.questname = "Ancient Tunnel";
  bossancient.lodname = sets["name_ancient"];
  bossancient.maxattacks = sets["attack_ancient"];
  bossancient.esc = esc_ancient;
  bossancient.quest = sets["quest_ancient"];
  bossancient.mindist = sets["attack_ancient"][2];
  bossancient.skill = skill_ancient;
  bossancient.pathbeforeattack = true;
  bossancient.checkchest = false;
  bossancient.kill_minions = true;
  bossancient.kill_nearboss = true;
  bossancient.classid = -1;
  bossancient.bFindItem = false;
  bossancient.freepositioncheck=false;
  //if (me.classid!=4) {
  	bossancient.GotoBoss = GotoAncientTunnel;
  	bossancient.killfunc = CleanAncientTunnel;
  //}
  listboss[23] = bossancient;
  
  bossmausoleum = new Object();
  bossmausoleum.name = "The Mausoleum";
  bossmausoleum.questname = "The Mausoleum";
  bossmausoleum.lodname = sets["name_mausoleum"];
  bossmausoleum.maxattacks = sets["attack_mausoleum"];
  bossmausoleum.esc = esc_mausoleum;
  bossmausoleum.quest = sets["quest_mausoleum"];
  bossmausoleum.mindist = sets["attack_mausoleum"][2];
  bossmausoleum.skill = skill_mausoleum;
  bossmausoleum.pathbeforeattack = true;
  bossmausoleum.checkchest = false;
  bossmausoleum.kill_minions = true;
  bossmausoleum.kill_nearboss = true;
  bossmausoleum.classid = -1;
  bossmausoleum.bFindItem = false;
  bossmausoleum.freepositioncheck=false;
  if (me.classid==1) {
  	bossmausoleum.GotoBoss = GotoMausoleum;
  	bossmausoleum.killfunc = CleanMausoleum;
  }
  listboss[24] = bossmausoleum;
  
  bossunique = new Object();
  bossunique.name = "Unique boss";
  bossunique.lodname = "";
  bossunique.maxattacks = sets["attack_unique"];
  bossunique.mindist = sets["attack_unique"][2];
  bossunique.esc = esc_unique;
  bossunique.quest = sets["kill_uniqueboss"];
  bossunique.skill = skill_unique;
  bossunique.pathbeforeattack = false;
  bossunique.checkchest = false;
  bossunique.kill_minions = sets["kill_minionsuniqueboss"];
  bossunique.kill_nearboss = false;
  bossunique.classid = 0;
  bossunique.bFindItem = true;
  bossunique.freepositioncheck=false;
  listboss[25] = bossunique;

  for ( var i = 0 ; i < nlistboss ; i++ ) {
    listboss[i].nbkill = 0;
    listboss[i].timekill = 0;
    listboss[i].nbescape = 0;
    listboss[i].nbnotfound = 0;
    listboss[i].xp = 0;
    listboss[i].lastxp=0;
    listboss[i].besttimekill = 0;
    listboss[i].worsttimekill = 0;
    listboss[i].lasttimekill = 0;
  };
}

function TimeToString( value )
{
    var h = parseInt( value/3600 );
    var m = parseInt( value/60 - h*60 );
    var s = parseInt( value - h*3600 - m *60 );
    return h+"h "+m+"m "+s+"s";
}

function LogLoad()
{
	if (!sets["do_loggings"]) return;
	var inifile="output/Dae_"+ me.name + "_Temp.ini";
	lf=fileOpen(inifile,0);
	if (lf)
	{
		lf.close();
		//var bosslogname=new Array("Kill","TimeKill","Escape","Notfound","Xp","BestTime");
		for(i=1;i<logname.length-1;i++)
		{
			log[logname[i]]=parseInt(Ele_ReadIniLine(inifile,"Character",logname[i]));
			if (isNaN(log[logname[i]])) log[logname[i]] = 0;
		}
		log["GameName"]=Ele_ReadIniLine(inifile,"Character","GameName");

		for(i=0;i<nlistboss;i++)
		{
			var _name=listboss[i].name;
//			if ( _Ele_CheckSectionExist( _Ele_ReturnIniCon(inifile),_name,inifile ) ) {
				listboss[i].nbkill=parseInt(Ele_ReadIniLine(inifile,_name,"Kill"));
				listboss[i].timekill=parseInt(Ele_ReadIniLine(inifile,_name,"TimeKill"));
				listboss[i].nbescape=parseInt(Ele_ReadIniLine(inifile,_name,"Escape"));
				listboss[i].nbnotfound=parseInt(Ele_ReadIniLine(inifile,_name,"NotFound"));
				listboss[i].xp=parseInt(Ele_ReadIniLine(inifile,_name,"Exp"));
				listboss[i].lastxp=parseInt(Ele_ReadIniLine(inifile,_name,"LastExp"));
				listboss[i].besttimekill=parseInt(Ele_ReadIniLine(inifile,_name,"BestTime"));
				listboss[i].worsttimekill=parseInt(Ele_ReadIniLine(inifile,_name,"WorstTime"));
				listboss[i].lasttimekill=parseInt(Ele_ReadIniLine(inifile,_name,"LastTime"));
//			};

        	if (isNaN(listboss[i].nbkill) || isNaN(listboss[i].timekill) || isNaN(listboss[i].nbescape)
        		|| isNaN(listboss[i].nbnotfound) || isNaN(listboss[i].xp) || isNaN(listboss[i].besttimekill)
        		|| isNaN(listboss[i].worsttimekill) || isNaN(listboss[i].lasttimekill) || isNaN(listboss[i].lastxp)){
        			listboss[i].nbkill=0;
        			listboss[i].timekill=0;
        			listboss[i].nbescape=0;
        			listboss[i].nbnotfound=0;
        			listboss[i].xp=0;
        			listboss[i].lastxp=0;
        			listboss[i].besttimekill=0;
        			listboss[i].worsttimekill=0;
        			listboss[i].lasttimekill=0;
        		}


		}
	}
	else
	{
		lf=fileOpen(inifile,1);
		if (!lf)
			return false;
		else
			lf.close();
	}

	function RemoveZero(number)
	{
		if (isNaN(number)) return 0;
		else return number;
	}
}


function LogSave(mode)
{
	//this function have been modified in version 0.42c.
	//now use new format!
	if (!sets["do_loggings"]) return;
	var inifile="output/Dae_"+ me.name + "_Temp.ini";

    var actualtime = (new Date()).getTime();
    	log["TotalTime"] += ( actualtime - begingame );
    begingame = actualtime;

    	lf=fileOpen(inifile,1);
	if (!lf)
		return false;
	
	lf.writeLine("[Character]");
	for(i=1;i<nlog;i++)
	{
		lf.writeLine(logname[i] +"=" + log[logname[i]]);
	}
	lf.writeLine(" ");
	for(i=0;i<nlistboss;i++)
	{
		lf.writeLine("[" + listboss[i].name + "]");
		lf.writeLine("Kill=" + listboss[i].nbkill);
		lf.writeLine("TimeKill="+listboss[i].timekill);
		lf.writeLine("Escape="+listboss[i].nbescape);
		lf.writeLine("NotFound="+listboss[i].nbnotfound);
		lf.writeLine("Exp="+listboss[i].xp);
		lf.writeLine("LastExp="+listboss[i].lastxp);
		lf.writeLine("BestTime="+listboss[i].besttimekill);
		lf.writeLine("WorstTime=" + listboss[i].worsttimekill);
		lf.writeLine("LastTime=" + listboss[i].lasttimekill);
		lf.writeLine(" ");
	}
	lf.close();

	if (mode==1)
	{
		//if (sets["html_logging"]) return HtmlLogging();
		lf=fileOpen(log["inifile"],1);
		if (!lf) 
			return false;
		lf.writeLine("-----={Daemon Multi-MF Bot Log file}=-----");
		lf.writeLine(" ");
		lf.writeLine("-----={Character}=-----");
		lf.writeLine("[>] Your Name : "+ me.name);
		lf.writeLine("[>] Your Life : "+ maxlife);
		lf.writeLine("[>] Your Mana : "+ maxmana);
		lf.writeLine("[>] Your Magic Find : " + me.getStat(80)+me.getStat(240)/8);
		for(var i=0;i<3;i++) merc=getMerc();
		if (merc) lf.writeLine("[>] Your Merc : "+ merc.name);
			lf.writeLine("[>] Your Average Ping : "+ parseInt(log["Ping"]/log["Total"]));

		lf.writeLine(" ");
		lf.writeLine("-----={Times and Rate}=-----");
		lf.writeLine("[>] Total MF Times : " + log["Total"]);
		lf.writeLine("[>] Success Times : " + log["Success"]);
		lf.writeLine("[>] Success Rate : " + parseInt(log["Success"]/log["Total"]*100) + "%");

	    var nboss = 0;
	    var nkill = 0;
	    for ( var i = 0 ; i < nlistboss ; i++ ) {
	        nboss += listboss[i].nbkill+listboss[i].nbescape+listboss[i].nbnotfound;
	        nkill += listboss[i].nbkill;
	    };
	    lf.writeLine("[>] Success Rate Boss : " + parseInt(nkill/nboss*100)+"%" );

		lf.writeLine("[>] Chicken out : " + (log["Total"]-log["Finish"]) );
		lf.writeLine("[>] Merc's chicken out : " + log["Merc_Chicken"]);
		lf.writeLine("[>] Died : " + log["Died"]);
		lf.writeLine("[>] Total run time : " + TimeToString(log["TotalTime"]/1000));
		lf.writeLine("[>] Total town Time : " + TimeToString(log["TimeInTown"]/1000));
		lf.writeLine("[>] Do Shop Times : " + log["ShopTimes"]);
		lf.writeLine("[>] Cube Times : " + log["CubeTimes"]);
		lf.writeLine(" ");
		lf.writeLine("-----={Bosses}=-----");

    for ( var i = 0 ; i < nlistboss ; i ++ ) {
      lf.writeLine( "[>] "+listboss[i].name );
  	  lf.writeLine("    Kill : " + listboss[i].nbkill +( listboss[i].quest==true ? " (Executed)" : " (Skipped)") );
  	  lf.writeLine("    Escape : " + listboss[i].nbescape );
  	  lf.writeLine("    Not found : " + listboss[i].nbnotfound );
  	  lf.writeLine("    Average time to kill : " + parseInt(listboss[i].timekill/listboss[i].nbkill/1000)+" sec" );
  	  lf.writeLine("    Best time to kill : " + parseInt(listboss[i].besttimekill/1000)+" sec" );
  	  lf.writeLine("    Worst time to kill : " + parseInt(listboss[i].worsttimekill/1000)+" sec" );
  	  lf.writeLine("    Time to kill last time : " + parseInt(listboss[i].lasttimekill/1000)+" sec" );
  	  lf.writeLine("    Experience : " + listboss[i].xp );
  	  lf.writeLine("    Last time get experience : " + listboss[i].lastxp);
    };
	lf.writeLine(" ");

	lf.writeLine("----------------------------");
	var d=new Date();
	lf.writeLine("Last Finish Time : " + d.toString());

	lf.close();
	}

}



//Dist
function Dist2(x1, y1, x2, y2) {
	return Math.floor((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }

function Dist(x1, y1, x2, y2) {
	return Math.floor(Math.sqrt(Dist2(x1, y1, x2, y2))); }

function myDist(x, y) {
	return Dist(me.x, me.y, x, y); }

// this function can do long distance with multiple teleports
// v0.27 new version
function Teleport(x, y, mindist, retry)
{
	if (!mindist || mindist < 3)
		mindist = 3;

	if (!retry)
		retry = 10;	// default 10 retries
	retry++;

	Sc_SetSkill("Teleport", right_hand);

	var target = new coord(x, y);
	var pos = new coord(me);
	var walkablepos;
	var retrywalkablepos;
	var dir = pos.dir(target);
	var lastpos = new coord(me);
	lastpos.data = 0;
	var teledist = 25;
	var movedist = teledist;

	retry += Math.floor(pos.dist(target) / teledist);

	DebugWrite("Teleport: (" + x + "," + y + ") dist: " + pos.dist(me));

	while(retry > 0) {
		while(me.mode == 10)
			delay(50);

		if (target.dist(me) <= mindist)
			return true;

		teledist = 25 + rnd(0,5);

		pos.set(me);
		dir = pos.dir(target);

		if (dir.x == 0 && dir.y == 0)
			return true;

		if (lastpos.dist(me) < 3) {
			lastpos.data++;
			if (lastpos.data > 2)
				dir.rotate(-90, 90);
		}
		else
			lastpos.data = 0;

		lastpos.set(me);
		if (target.dist(me) > teledist)
			pos.move(dir, teledist);
		else {
			pos.set(target);
		}

		CastSkillAt(0,pos.x, pos.y);
		delay(50);
/*		while (me.mode==10) delay(20);
		CheckMe();
		delay( 250 );*/
		retry--;

		if (target.dist(me) <= mindist)
			return true;

		DebugWrite("Teleport done, " + retry);
		CheckMe();
		DebugWrite("CheckSelf in teleport done");
	}
	DebugWrite("Teleport failed");
	return false;
}


function TeleportTo(x, y) {
    Teleport( x, y );
	while (me.mode == 10) delay(10);
}

function TeleportToward(x, y, delta) {
	var _targetx = me.x;
	var _targety = me.y;
	r = myDist(x, y);
	if (delta > 0 && r <= delta) {
		_targetx = x;
		_targety = y; }
	else {
		_targetx = Math.floor(me.x + (delta * (x - me.x) / (r > 0 ? r : 1)));
		_targety = Math.floor(me.y + (delta * (y - me.y) / (r > 0 ? r : 1))); }
	TeleportTo(_targetx, _targety); }

//Screen Hook
function SHook(hook,x,y,text,sfont,scolor) {
  if ( sets["use_screenhook"] && hook )
    AlwaysSHook( hook, x, y, text, sfont,scolor );
}

function SHook2(hook,text) {
  if ( sets["use_screenhook"] && hook )
    AlwaysSHook2(hook,text);
}

function AlwaysSHook(hook,x,y,text,sfont,scolor)
{
	var tx=0;
	var ty=0;
	if (me.screensize==0)
	{
		tx=x*0.8;
		ty=y*0.8;
	}
	else
	{
		tx=x;
		ty=y;
	}
	hook.color=scolor;
	hook.x=tx;
	hook.y=ty;
	hook.font=sfont;
	hook.text=String(text);
}

function AlwaysSHook2(hook,text)
{
	hook.text=String(text);
}

function ShowBar()
{
	//ScreenHook

    if ( sets["use_screenhook"] ) {

      var version=getScreenHook();
      SHook(version,240,516,"--- Daemon Multi-MF Bot "+CURRENT_VERSION+" Beta ---",null,4);

      sl = getScreenHook();
      SHook(sl,250,35,"No target",null,1);

      var job = getScreenHook();
      SHook(job,50,300,"--------Quests--------",4,8);

      //Character
      var chars = getScreenHook();
      SHook(chars,630,150,"------Character------",4,8);

      var cname = getScreenHook();
      SHook(cname,630,165,"Name - "+ me.name,4,0);

      var cmerc = getScreenHook();
      merc=getMerc();
      if (merc) SHook(cmerc,630,210,"Merc - "+ merc.name,4,0);
      else SHook(cmerc,630,210,"Merc - None",4,0);

      var cmf = getScreenHook();
      SHook(cmf,630,225,"Magic Find - " + (me.getStat(80)+me.getStat(240)) + " %",4,0);

  	  //Logging
	  var logs=getScreenHook();
	  SHook(logs,560,300,"-------Logging-------",4,8);
      ShowBar2();

    };
}


function ShowBar2() {
  if ( sets["use_screenhook"] )
    UpdateLogScreen();
};

//xx
function StashFunc(stash)
{
	DebugWrite("Stash func started");

    if ( sets["new_id_code"] )
        IDList.Stash();
    else {
        var done = false;
        while(!done) {
            DebugWrite("Itemloop again");
            done = true;
            var item = getUnit(4, null, 100);
            do {
                if (item.mode == 4 && item.getParent() && item.getParent().name == me.name) {
                    DebugWrite("Item on cursor, dropping it");
                    item.cancel(0);
                    delay(500);

                    done = false;
                    break;
                }

                if (item && item.mode == 0 && item.itemloc == 0 && !item.getFlag(0x10)) {
                    if (!(CheckItem(item, sets["snag_ini"] ) && idValid))
                        continue;
                    var p = item.getParent();
                    if (!p || (p && p.name != me.name))
                        continue;

                    DebugWrite("StashFunc: found item");
                    // id the item
                    // stash if needed, else drop it
                    var s = LocateItem(me, "isc", 100);
                    if (!s) {
                        s = LocateItem(me, "ibk", 100);
                        if (!s || !s.getStat(70)) {
                            DebugWrite(" * ERROR: No ID Scroll or empty tome");
                            return;
                        }
                    }

                    DebugWrite("Found scroll, going to id the item");
                    var x = item.x;
                    var y = item.y;
                    do {
                        clickItem(1, s);
                        DebugWrite("RightClicked scroll");
                        delay(500);
                        clickItem(0, item);
                        delay(500);
                        if (item.mode == 4) {
                            delay(50);
                            while(item.mode == 4) {
                                clickItem(0, x, y, 0);
                                delay(500)
                            }
                        }
                        DebugWrite("Using scroll on item");
                    }while(!item.getFlag(0x10));
                    DebugWrite("Item Id'd");

                    if (ParseIt(sets["parseitfile"], item.x, item.y, 1)) {
                        DebugWrite("stashing item");
                        Town.StashItem(item);
                        done = false;
                        break;
                    }
                    else {
                        DebugWrite("dropping item");
                        while(item.mode != 4) {
                            clickItem(0, item);
                            delay(500);
                        }
                        DebugWrite("Item put on cursor");
                        while(item.mode == 4) {
                            item.cancel(0);
                            delay(500);
                        }
                        DebugWrite("item dropped");
                        done = false;
                        break;
                    }
                }
            }while(item && item.getNext(null,100));
        }
    };

	CubeGems();
	DebugWrite("StashFunc done");
}

function ShopFunc(npc)
{
	DebugWrite("Shopfunc called on "+npc.name);

	if (!sets["shop"] || MyGold() < sets["mingoldshop"] ) {
		DebugWrite("Shopping disabled");
		return;
	}

	if (!npc) {
		DebugWrite(" * ERROR: No NPC in ShopFunc");
		return;
	}

	var resShopIt = DaeBM_ShopIt(npc.name, npc);
	if ( resShopIt && ( ( typeof( resShopIt ) == "boolean" ) || resShopIt.length ) )
        sthShopped = true;
}

function StashGoldFull()
{
	   var maxGold;
	   var level = me.getStat(12);
	   if (level < 30) maxGold = Math.floor((level + 10) / 10) * 50000;
	   else maxGold = 800000 + Math.floor((level - 30) / 2) * 50000;
	   return (maxGold == me.getStat(15));
}

function NeedStash(noprint)
{
	DebugWrite("NeedStash called");

	var gld = me.getStat(14);

	DebugWrite("Gold: " + gld + ", StashGoldAmount: " + sets["stash_gold_amount"]);
	if (gld && sets["stash_gold_amount"] > 0 && gld >= sets["stash_gold_amount"] && !StashGoldFull()) {
		if (!noprint) bprint("Need to stash gold");
		return true;
	}

	DebugWrite("No need to stash gold");

    if ( !sets["new_id_code"] ) {
        // dont know howmuch types there are
        var nostashlist = new Array();
        nostashlist[5] = true;
        nostashlist[6] = true;
        nostashlist[18] = true;
        nostashlist[76] = true;
        nostashlist[77] = true;
        nostashlist[79] = true;
        nostashlist[80] = true;
        nostashlist[81] = true;
        nostashlist[22] = true;
        nostashlist[41] = true;
        nostashlist[78] = true;

        DebugWrite("Going to look trough the items");

        var item = getUnit(4, null, 100);
        do {
            if (item && item.mode == 0 && item.itemloc == 0 && item.getParent() && item.getParent().name == me.name && getBaseStat(0,item.classid,56) && !nostashlist[getBaseStat(0,item.classid,56)]) {
                DebugWrite("Checking item: " + item.code);
                if (getBaseStat(0,item.classid,56) == 82 || getBaseStat(0,item.classid,56) == 83 || getBaseStat(0,item.classid,56) == 84) {
                    if (!item.getFlag(0x10)) {
                        DebugWrite("Need to ID and stash a charm");
                        return true;
                    }
                }
                else {
                    DebugWrite("Need to stash an item");
                    return true;
                }
            }
        }while(item && item.getNext(null,100));
    };

	DebugWrite("NeedStash done");
}

function NeedIdScrolls()
{
	need_id_scrolls = 0;
	var item = getUnit(4, null, 100);

	do {
		if (item && item.mode == 0 && item.itemloc == 0 && !item.getFlag(0x10)) {
			if ((item.code == "cm1" || item.code == "cm2" || item.code == "cm3" || item.code == "jew")) {
				need_id_scrolls++;
			}
			else if (CheckItem(item, sets["snag_ini"]) && idValid) {
				print("Need to ID: "+item.code);
				need_id_scrolls++;
			}
		}
	}while(item && item.getNext(null,100));

	return need_id_scrolls;
}

function BuyKeysAtNpc( npc, mode ) {
	var keys = GetKeys();

    if(!mode) mode=true;
    if ( ( needkey>0 || !keys ) && sets["buy_key"]) // if keys are done (because IDing)
    {
		if ( keys || !IsInventoryFull() )  // not full or we have keys
		{
		    if ( BuyItem( npc, "key", mode ) )
				bprint("Bought some keys");
			else {
				DebugWrite(" * ERROR: Failed to buy Key");
				delay(100);
			}
		}
	};
};

function HealFunc(npc)
{
    if ( !sets["new_id_code"] ) {
        while(need_id_scrolls > 0) {
            var s = LocateItem(npc, "isc", -1);
            if (s) {
                var gld = me.getStat(14) + me.getStat(15);
                if (gld<shopitem.getItemCost(0))
                {
                	bprint("Not enough money to buy a ID scroll!");
                }
                else
                {
	               
	                var retry = 0;
	                do {
	                    bprint("Buying id scroll");
	                    s.shop(npc, 2);
	                    delay(1000);
	                }while( ( gld == (me.getStat(14) + me.getStat(15)) ) && ( retry++ < 10 ) );
	                need_id_scrolls--;
	        }
            }
            else {
                DebugWrite(" * ERROR: Failed to buy ID scroll");
                delay(100);
            }
        }
    }
    else {
        if ( IDList.NeedIdOrSell(sets["sell_items"]) ) {
            if ( IDList.nbID ) {
                IDList.TryID( npc );
                IDList.Check( true );
            };
            if ( sets["sell_items"] && IDList.nbDrop )
                IDList.Sell( npc );
        };
    };

	var keys = GetKeys();
	if ( me.act != 3 ) BuyKeysAtNpc( npc );
	else if (keys && needkey>0) {
		SellItem( npc, keys );
		DoDel(500);
		BuyKeysAtNpc( npc, false );
	}
	needkey=NeedKeys();


     frozen = sets["healifcursed"] && me.getState(11);

     if ( frozen && sets["healifcursed"])
     {
     	if (!IsInventoryFull())
     	{
     		DoDel(100);
     		var s=LocateItem(npc,"wms",-1);
     		if (s)
     		{
     			var gld = me.getStat(14) + me.getStat(15);
     			if (gld<s.getItemCost(0)) bprint("Not enough money to buy a Thawing pot!");
     			else
     			{
	                	var retry = 0;
				do {
	                    		s.shop(npc, 2);
					delay(1000);
				}while( (gld == (me.getStat(14) + me.getStat(15)) ) && ( retry++ < 10 ) );
	    		}
    		}
    		else bprint("Failed to buy Thawing Pot!");

    		var s=LocateItem(me,"wms",100);
    		if (s)
    		{
    			bprint("Bought a Thawing pot and drink it!");
    			clickItem(1,s);
    			delay(200);
    		}
    		else bprint("Failed to drink Thawing pot!");
    	}
    }
    ShopFunc(npc);
}

function RepairFunc(npc)
{
	var keys = GetKeys();
	if ( me.act == 3 ) BuyKeysAtNpc( npc );
	else if (keys && needkey>0) {
		SellItem( npc, keys );
		DoDel(500);
		BuyKeysAtNpc( npc, false );
	}
	needkey=NeedKeys();

    ShopFunc(npc);
};

function LocateItem(who, itemcode, loc)
{
    if ( loc == -1 )
      loc = 0;

	var start=getUnit(4, itemcode, loc );
	do {
		if(start) {
			if(who)
            {
		        punit=start.getParent();
				if (punit && punit.name==who.name )
                    return start;
			};
        }
        else return start;
	} while(start && start.getNext(itemcode, loc));

	return null;
}


function Sc_SetSkill(skill, hand)
{
	if (isNaN(skill)){	
		if ( !me.getSkill( skill,0) )
			return false;
		me.setSkill(skill, hand);
	
		timer = 2000;
		while(me.getSkill(hand).toLowerCase() != skill.toLowerCase() && timer >= 0) {
			delay(20);
			timer -= 20;
		}
		if (timer < 0)
			return false;
	
		return true;
	}
	else {
		if ( !me.getSkill( parseInt(skill),0) )
			return false;
		
		me.setSkill(parseInt(skill), hand);
	
		timer = 2000;
		while(me.getSkill(hand+2) != skill && timer >= 0) {
			delay(20);
			timer -= 20;
		}
		if (timer < 0)
			return false;
	
		return true;
	}
}

function doWeaponSwitch(switchTo)
{
	if (arguments.length < 1)
		switchTo = (weaponSwitch(1)==0)?1:0;

    if ( weaponSwitch(1) == switchTo )
        return true;

	var beginswitch = (new Date()).getTime();
	while ( ( me.mode > 7 ) && ( me.mode != 17 ) ) {
		delay( 20 );
		CheckMe();
	};

    var retry = 0;
	var retry2 = 0;
    while ( ( weaponSwitch(1) != switchTo )  && ( retry2++ < 3 ) ) {
        weaponSwitch();

		retry = 0;
        while ( ( weaponSwitch(1) != switchTo ) && ( retry++ < 10 ) ) {
          CheckMe();
  		  delay( 40 );
        };
    };

	var endswitch = (new Date()).getTime();
	if (weaponSwitch(1) != switchTo) {
		bprint("Weapon switch failed after approximately " + (endswitch-beginswitch) + " ms");
        return false;
    }
	else {
		bprint ("weapon switch to " + switchTo + " took approximately " + (endswitch-beginswitch) + " ms");
        return true;
    };
}

function GetCastRate(fcr)
{
	if(fcr < 9)
		return 13;
	else if (fcr < 20)
		return 12;
	else if (fcr < 37)
		return 11;
	else if (fcr < 63)
		return 10;
	else if (fcr < 105)
		return 9;
	else
		return 8;
}

function DebugWrite(msg)
{
//  bprint(msg);
	if (sets["debug"]) {
		var d = new Date();
		var f = fileOpen(Dae_debug_file, 2);
		if (!f) {
			Error("Failed to open logfile");
			return;
		}

		f.writeLine(CURRENT_VERSION + ": [" + d.toLocaleString() + "] " + msg);
		f.flush();
		f.close();
	}
}

//zz
function MyDebugWrite(msg,index)
{
	if ( index == 2 ) return;

  bprint(msg);
		var d = new Date();
        if ( !index )
            index = "";
		var f = fileOpen(Dae_debug_file+index, 2);
		if (!f) {
			Error("Failed to open logfile");
			return;
		}

		f.writeLine(CURRENT_VERSION + ": [" + d.toLocaleString() + "] " + msg);
		f.close();
}

function CheckBloodMana()
{
	return (me.getState(114)); 	//Blood Mana
}

// Like Sh_FollowPathToThing2 but kill unique boss on the way
// DistPath = 0, try to return to original position
function Sh_FollowPathToThingEx(path, x, y, DistPath )
{
    if ( !sets["kill_uniqueboss"] )
      return Sh_FollowPathToThing2( path, x, y );

    var deadlock = 0;
    var i = 1; //v0.27 no need to teleport on self ;)
    var t1 = 0, t2 = 0, t3 = 0;
    TeleportDeadlock = 5; // => think it is enough because Teleport can do long teleport

    looprestart: while (i < path.length && myDist(x, y) > 10)
    {
        oldx = me.x;
        oldy = me.y;

        if (deadlock > TeleportDeadlock)
        {
          bprint("Deadlock teleporting to destination...aborting...");
          DebugWrite("Deadlock teleporting to destination...aborting...");
          return false;
        }

        if ( ((t1+t3) % sets["check_unique_every_hop"]) ==0 ) {
            if ( KillAllNearUniqueBoss() ) {
                // check if we are near a path point
                for ( var j = 0 ; j < path.length ; j++ ) {
                    var distpoint = Dist2( path[j][0], path[j][1], me.x, me.y );
                    if ( distpoint < 25*25 ) {
                        if ( distpoint > 10*10 )
                            Teleport( path[j][0], path[j][1], 5 );
//                        bprint("restart from position "+(j+1)+" we was "+i ); //zz
                        i = j+1;
                        continue looprestart;
                    };
                };
                if ( DistPath ) {
                    var newpath = Sh_FindPath(x, y, DistPath);
//                    bprint("repathing "+ newpath.length ); //zz
                    if ( newpath ) {
                        path = newpath;
                        i = 1;
                        deadlock = 0;
                        continue looprestart;
                    };
                }
                Teleport( oldx, oldy, 10 ); // yes it seems stupid but it works most of time ;)
            };
        };

		if ( CheckIfReturnInTown( (sets["town_min_col_inventory"]>0) ) )
			BackToTown();

	if (CheckBloodMana())
	{
		switch(sets["blood_mana"])
		{
			case 1:		//back to town,ask for heal;
				var changed=false;
				backtown++;
				if (backtown>sets["max_backtown"]) break;
				if (FindEnemyNear(me,5))
				{
					target=FindEnemyNear(me,5);
					datapos = initgoodpos( 10, 15 );
   					checkgoodposex( datapos, target, 1 );
     					changed=true;
				}
				delay(300);
				bprint("I was cursed with Blood Mana,ask for heal.");
				Town.Heal(HealFunc,true);
				if (changed)
				{
					 for ( var j = 0 ; j < path.length ; j++ ) {
                  			  var distpoint = Dist2( path[j][0], path[j][1], me.x, me.y );
                    			  if ( distpoint < 25*25 ) {
                        			if ( distpoint > 10*10 ) Teleport( path[j][0], path[j][1], 5 );
			                        i = j+1;
                        			continue looprestart;
                    			};
                			};
                		}
				break;
			case 2:
				bprint("I was cursed with Blood Mana,have a rest.");
				var timer=3000;
				while(me.getState(114) && timer>0)
				{
					DoManaRecharge();
					delay(500);
					timer-=500;
				}
				 for ( var j = 0 ; j < path.length ; j++ ) {
                  			  var distpoint = Dist2( path[j][0], path[j][1], me.x, me.y );
                    			  if ( distpoint < 25*25 ) {
                        			if ( distpoint > 10*10 ) Teleport( path[j][0], path[j][1], 5 );
			                        i = j+1;
                        			continue looprestart;
                    			};
                		};
				break;
			case 3:
				break;
			default:
				break;
		}
	}

        Teleport( path[i][0], path[i][1], 5, 1 );
        t1++;
        if ( ( myDist(oldx, oldy) < 5 ) )
        {
            TeleportRandomly2();
            t3++;
        };

        if (myDist(path[i][0], path[i][1]) < 20)
        {
			CheckObjects( true, DaeShrineMove );
            ++i;
            deadlock = 0;
        }
        else
            deadlock++;
   }
   DebugWrite("Sh_FollowPathToThingEx end");
   return true;
}

function KillAllNearUniqueBoss( maxdistboss )
{
    if ( !sets["kill_uniqueboss"] )
        return false;

    var bossed = false;

    var boss = CheckNearNormalBoss( maxdistboss );
    if ( boss ) {
        bossed = true;
        do {
            KillNormalBoss( boss );
            boss = CheckNearNormalBoss( maxdistboss );
        } while ( boss );
    };
	DebugWrite( "KillAllNearUniqueBoss end" );
    return bossed;
}


    function CheckIsSuper( npc ) {
        for(var i=0;i<listboss.length;i++) {
            if (npc.name == listboss[i].lodname || npc.classid == listboss[i].classid )
                return true;
        };
        return false;
    };

    function BossIsWrongClassID( npc ) {
        for(var i=0;i<sets["skip_uniquetype"].length;i++) {
            if (npc.classid == sets["skip_uniquetype"][i])
                return true;
		};
		return false;
	};

    function CheckIsWrongType( npc ) {
        for(var i=0;i<sets["skip_uniquetype"].length;i++) {
            if (npc.classid == sets["skip_uniquetype"][i])
                	return true;
		};
		for (var k=0;k<speclist.length;k++)
		{
			if ( !sets["kill_special"] && npc.name.indexOf(speclist[k])!=-1 ) return true;
		}
		if ( npc.mode == 12 ) // death monster :eyes:
			return true;
		merc=Town.GetMerc();
		if (merc){
			if (merc.name==npc.name) return true;
		}
        return false;
    };

    function CheckIsKilled( npc ) {
        for(var i=0;i<killedboss.length;i++) {
            if (npc.name == killedboss[i])
                return true;
        };
        return false;
    };

// 0 = OK
// 1 = Bad thing
// 2 = Very bad (chicken boss or boss with bad classid)
function CheckIsBadThingThere( target, range ) {
	var pos = new coord(target);
	var npc=getUnit(1);
	var res = 0;
	if ( npc ) do
	{
		if ( npc.mode == 12 || pos.dist2( npc ) > range*range )
			continue;
		var TypeMonster = CheckMonster( npc );
		if ( TypeMonster >= 1 ) {

			if ( BossIsWrongClassID( npc ) ){
				if ( TypeMonster == 2 )
					return 2;
				else
					res = 1;
				}

        		if ( TypeMonster == 2 ) {
				var inter = checkenchant2(npc, bossunique.esc);
				if (inter==2)
					return 2;
			};
		};
	}while( npc && npc.getNext());
	return res;
}

function CheckNearNormalBoss( maxdistboss )
{
    var bossname = "";
    var bossid = 0;
    var distboss = 2500; //50*50
	if ( maxdistboss )
    	distboss = maxdistboss*maxdistboss;
	var npc=getUnit(1);
	if (npc) do
	{
        if ( CheckMonster( npc ) == 2 ) {
            if ( CheckIsSuper( npc ) && ( npc.mode != 12 ) ) // first the super boss then the others (=> because sometimes, i kill the superboss in the same time !!!)
                return null;

            var newdistboss = Dist2( me.x, me.y, npc.x, npc.y );
            if ( newdistboss < distboss && !CheckIsWrongType( npc ) && !CheckIsKilled( npc )  ) {
                bossname = npc.name;
                bossid = npc.id;
                distboss = newdistboss;
			}
		}
	}while( npc && npc.getNext());

    if ( bossid ) {
        npc=getUnit(1,bossname);
        if (npc) do
        {
            if ( npc.id == bossid )
                return npc;
        }while( npc && npc.getNext());
    };
    return null;
}

function KillNormalBoss( boss )
{
    var beginkill = (new Date()).getTime();
    var beginxp = GetExperience();

	killedboss.push(boss.name); // even if not killed
    bossunique.classid = boss.classid;
    bossunique.lodname = boss.name;
    bossunique.boss = boss;

	var inter = checkenchant2(boss, bossunique.esc);
	if (inter==2) {
		disenchant(boss);
        escape( boss );
        return 0;
    };

    print ("ÿc1[>]ÿc@Starting Kill ÿc2" + boss.name);
	ShowState("ÿc1[>]ÿc@Starting Kill ÿc2" + boss.name);

    DoBoss( GotoUniqueBoss, bossunique );

    timelost += ( (new Date()).getTime() - beginkill );
    xponunique += ( GetExperience()-beginxp );

    return;
}

function checkquest()
{
	if (!sets["check_quest"]) return;
	for(i=0;i<nlistboss-1;i++)
	{
		if (listboss[i].nbkill==0 && listboss[i].nbescape==0 && listboss[i].nbnotfound>=5 && listboss[i].quest)
		{
			if (listboss[i].name != bosscows.name)
			{
                listboss[i].quest=false;
                bprint("Quest: ÿc2" + listboss[i].name + " ÿc@is always failed ! Skip it!");
			}
		}
	}

}

function checkimmune()
{
	if (me.classid!=1) return;
	if ( sets["auto_skill"] ) return;

	var printed=false;

	var _immlist=new Array();
	var _imm=new Object();
	_imm.fire=false;
	_imm.lighting=false;
	_imm.cold=false;

	for(i=0;i<nlistboss;i++)
	{
		var _type=0;
		for(k=0;k<listboss[i].skill.length;k++)
		{
			_type=SkillType(listboss[i].skill[k]);
			if (_type) _imm[_type]=true;
		}

		if (_imm.fire) _immlist.push(-39);
		if (_imm.lighting) _immlist.push(-41);
		if (_imm.cold) _immlist.push(-43);

		if (_immlist.length==0) return;
		else _immlist.push(true);

		var found=false;
		for(j=0;j<listboss[i].esc.length;j++)
		{
			if (listboss[i].esc[j]==_immlist)
			{
				found=true;
				break;
			}
		}
		if (!found)
		{
			listboss[i].esc[listboss[i].esc.length]==_immlist;
			if (!printed)
			{
				var firestr=_imm.fire? "Fire Immune + " : "";
				var lightstr=_imm.lighting? "Lighting Immune + " : "";
				var coldstr=_imm.cold?"Cold Immune" : "";
				bprint("Add [ ÿc2" + firestr  + lightstr  +  coldstr + ",trueÿc@ ] to your enchant list!");
				printed=true;
			}
		}
	}
}

function SkillType(skill)
{
	//var light_immune = (target.getStat(41) > 99);
	//var fire_immune = (target.getStat(39) > 99);
	//var cold_immune = (target.getStat(43) > 99);

	switch (skill)
	{
		case "Fire Bolt" :
		case "Inferno" :
		case "Blaze" :
		case "Fire Ball" :
		case "Fire Wall" :
		case "Enchant" :
		case "Hydra" :
		case "Meteor" :
			return ("fire");

		case "Chain Lightning" :
		case "Lightning" :
		case "Thunder Storm" :
		case "Nova" :
		case "Telekinesis" :
		case "Static Field" :
		case "Charged Bolt" :
			return ("lighting");

		case "Frozen Orb" :
		case "Blizzard" :
		case "Frost Nova" :
		case "Ice Blast" :
		case "Glacial Spike" :
		case "Ice Bolt" :
		case "Chilling Armor" :
		case "Shiver Armor" :
		case "Frozen Armor" :
			return ("cold");

		default:
			bprint("Euh ?? skill "+skill+" unknown !!" );
			return false;
	}
}

function CubeGems()
{
//now it's only a test! only can cube PGs... by Killkeeper
//new function in version 0.42.
	
	if (me.pingtimer>1000) return;
//in 0.47,can cube more!
	if (!sets["cube"]) return;
	var gemlist=new Array("gzv","glw","glg","glr","glb","skl","gly");
	if (sets["cube_runes"])
	{
		for(a=1;a<sets["cube_runesMax"];a++)
			{
				eval("gemlist.push('r0"+a+"')");
			}
	}
	var perfectgemlist=new Array("gpw","gpv","gpb","skz","gpy","gpr","gpg");
	var chippedgemlist=new Array("gcv","gcw","gcg","gcr","gcb","gcy","skc");
	var bOpenedStash = false;
	bprint("Now starting to cube.");
	DebugWrite("Now starting to cube flawless gems.");
	//start
	if ( CheckCube() ) {
		if (!getUIFlag(c_UIFlag_Cube)) {
			if(!getUIFlag(c_UIFlag_Stash)) {
				if ( OpenStash() )
					bOpenedStash = true;
				else
					return false;
			};
			if ( !OpenCube() )
				return false;
		};
		if (sets["cube_pg"])
		{
			if ( CleanCube() )
				StartCube();
		}
	};

	for(i=0;i<sets["cube_stuff"].length;i++)
	{
		switch (sets["cube_stuff"][i])
		{
			case "nsc":
				CubeSC(true,"cm1");
				break;
			case "sc":
				CubeSC(false,"cm1");
				break;
			case "cb":
				CubeSC(false,"7gd");
				break;
			case "cs":
				CubeSC(false,"7bf");
			case "mbow":
				CubeSC(false,"amb");
				break;
			case "mbow2":
				CubeSC(false,"amc");
				break;
			case "jewel":
				CubeSC(false,"jew");
			case "lc":
				CubeSC(false,"cm2");
				break;
			case "gc":
				CubeSC(false,"cm3");
				break;
			default:
				bprint("Unknown stuff : " + sets["cube_stuff"][i]);
		}
	}

	CloseCube();
	if ( bOpenedStash )
		CloseStash();

	for(i=0;i<sets["cube_stuff_custom"].length;i++)
	{
		CubeSC(false,sets["cube_stuff_custom"][i][0],sets["cube_stuff_custom"][i][1]);
	}

	function CubeSC(bNSC,itemcode,gemtype)
	{
		if (me.pingtimer>1000) return;
		if (itemcode=="7gd" || itemcode=="7bf" || gemtype==2) var pglist=chippedgemlist;
		else if(gemtype==1) var pglist=perfectgemlist;
		else var pglist=perfectgemlist;

		if (itemcode=="cm1") var scmode=104;
		else var scmode=0;

		var box=getUnit(4,"box",0);
		CleanCube();
		CloseCube();
		var sc=getUnit(4,itemcode,scmode);
		if (sc) do
		{
			if (sc && !CheckItem(sc,sets["cube_ini"]) && sc.itemloc==4)
			{

				if (bNSC && sc.code=="cm1")
					if (sc.ilvl<95) continue;
				if (sc.code=="jew")
					if (sc.getFlag(0x08)==8) continue;

				var pgarr=new Array();
				var pgcount=0;
				for(i=0;i<pglist.length;i++)
				{
					var pg=getUnit(4,pglist[i],0);
					if (pg) do
					{
						if (pg && pg.code==pglist[i] && pg.mode != 6)
						{
							pgarr[pgarr.length]=pg.gid;
							pgcount++;
						}
					}while(pg.getNext());
				}
				if (pgcount>=3)
				{
					var pgput=0;
					for(k=0;k<Math.floor(pgcount/3);k++)
					{
						var count=0;
						while(count<3)
						{
							var fs=getFreeSpace(1,1,103);
							if (!fs) return false;
							CloseCube();
							var gem=getItem(pgarr[pgput]);
							if (!gem) return false;
							clickItem(0,gem);
							var retries=0;
							while(retries++<5 && gem.mode!=4) delay(150);
							if (gem.mode!=4) return false;

							do {
								clickItem(0,box);
								delay(500);
							}while(gem.mode == 4);
							count++;
							pgput++;
						}
						if (k==0)
						{
							clickItem(0,sc);
							var retries=0;
							while(retries++<5 && sc.mode!=4) delay(150);
							if (sc.mode!=4) return false;

							do{
								clickItem(0,box);
								delay(500);
							}while(sc.mode == 4)
						}

						DoDel(100);
						if (!OpenCube()) return false;

						transmute();
						var cubesc=getUnit(4,itemcode,103);
						if (!cubesc) return;
						if (CheckItem(cubesc,sets["cube_ini"]))
						{
							bprint("Transmute something you prefered!");
							CleanCube();
							Slog(cubesc,"keep");
						}
						DoDel(100);
						if (!CloseCube()) return false;
					}
					if (!CleanCube()) return false;
					return true;
				}
			}
		}while(sc.getNext(itemcode,scmode));
		if (!sc && sets["collect_recipe"] && sets["cube"]) stuffneed[itemcode]=true;
	}

	function getItem(gid)
	{
		item=getUnit(4,null,0);
		do
		{
			if (item && item.gid==gid) return item;
		}while(item && item.getNext());
	}

	function CleanCube()
	{
		while ( true ) {
			var item=getUnit(4,null,103);
			if (!item) return true;

			if ( !OpenCube() )
				return false;

			//move out
			var freespace=getFreeSpace(GetSizeX(item),GetSizeY(item),104);
			if (!freespace)
			{
				bprint("No enough room to store the item in the cube!");
				return false;
			}
			clickItem(0,item);
			var retries=0;
			while(retries++<5 && item.mode!=4) delay(500);
			if (item.mode!=4)
				return false;

			CloseCube();

			DoDel(400);
			do {
				clickItem(0,freespace.x,freespace.y,4);
				delay(500);
			}while(item.mode == 4);
		}
	}

	function StartCube()
	{
		var cubetimes =0;
		for(var i=0;i<gemlist.length;i++)
		{
			var gemcount=0;

			var gem=getUnit(4,gemlist[i],0);
			if (gem) do
			{
				gemcount++;
			}while(gem && gem.getNext(gemlist[i],0));

			while (gemcount>=3)
			{
				if (!DoOnceCube(gemlist[i]))
				{
					bprint("Cube failed!");
					return false;
				}
				gemcount-=3;
				if (!CleanCube()) return false;
				cubetimes++;
			}
		}
		if (cubetimes==0) bprint("Not enough flawless gems in your stash / inventory!");
		return true;
	}

	function CheckCube()
	{
		var cubetimes=0;
		for(var i=0;i<gemlist.length;i++)
		{
			var gemcount=0;

			var gem=getUnit(4,gemlist[i],0);
			if (gem) do
			{
				gemcount++;
			}while(gem && gem.getNext(gemlist[i],0));

			while ( gemcount>=3 )
			{
				gemcount-=3;
				cubetimes++;
			}
		}
		if (cubetimes==0)
		{
			bprint("Not enough flawless gems in your stash / inventory!");
			return false;
		}
		return true;
	}


	function DoOnceCube(_name)
	{
		var box=getUnit(4,"box",0);
		if (!_name || !box || !CloseCube() ) return false;

		var gem=getUnit(4,_name,0);
		var count=0;
		if (gem) do
		{
			var freespace=getFreeSpace(1,1,103);
			if (!freespace) return false;
			clickItem(0,gem);
			var retries=0;
			while(retries++<5 && gem.mode!=4) delay(150);
			if (gem.mode!=4) return false;

			do {
//				clickItem(0,freespace.x,freespace.y,3);
				clickItem(0,box);
				delay(500);
			}while(gem.mode == 4);
			count++;
			DoDel(100);
		}while(gem && gem.getNext(_name,0) && count<3)

		DoDel(100);
		if ( !OpenCube() )
			return false;

		transmute();
		DoDel(100);
		log["CubeTimes"]++;
		return true;
	}

	function OpenStash()
	{
		Town.MoveTo("stash",me.act);
		var stash=getUnit(4,"stash",0);
		if ( stash ) {
			var retry = 0;
			while (!getUIFlag(c_UIFlag_Stash) && ( retry++ < 5 ) ) {
				ClickMap(stash);
				delay(500);
			};
		};
		return getUIFlag(c_UIFlag_Stash);
	};

	function OpenCube()
	{
		var box=getUnit(4,"box",0);
		if ( box ) {
			var retry = 0;
			while (!getUIFlag(c_UIFlag_Cube) && ( retry++ < 5 ) ) {
				clickItem(1,box);
				delay(500);
			};
		};
		return getUIFlag(c_UIFlag_Cube);
	};

	function CloseCube()
	{
		var box=getUnit(4,"box",0);
		if ( box ) {
			var retry = 0;
			while (getUIFlag(c_UIFlag_Cube) && ( retry++ < 5 ) ) {
				box.cancel(0);
				delay(500);
			};
		};
		return !getUIFlag(c_UIFlag_Cube);
	};

	function CloseStash()
	{
		var stash=getUnit(2,"bank");
		if ( stash ) {
			var retry = 0;
			while (getUIFlag(c_UIFlag_Stash) && ( retry++ < 5 ) ) {
				stash.cancel(0);
				delay(500);
			};
		};
		return !getUIFlag(c_UIFlag_Stash);
	}
	bprint("Cube done!");
	DebugWrite("Cube for Perfect Gems finished!");
}

function getFreeSpace(_x,_y,_mode)
{
	var sizeX, sizeY;
	sizeX = 6;sizeY = 8;
	if (_mode==103)
	{
		sizeX=3;
		sizeY=4;
	}
	else if (_mode==100)
	{
		sizeX=10;
		sizeY=4;
	}
	else if ( sets["d2_classic"] )
		sizeY = 4;

	var stashspace = new Array(sizeX);
	for (var x = 0; x < sizeX; x++)
	{
		stashspace[x] = new Array(sizeY);
		for (var y = 0; y < sizeY; y++) stashspace[x][y] = "empty";
	}


	var sitem = getUnit(4,null,_mode);
	if (sitem) do
	{
		for (var x = 0; x < GetSizeX(sitem); x++)
		{
			for (var y = 0; y < GetSizeY(sitem); y++)
			{
				stashspace[x + sitem.x][y + sitem.y] = "full";
			}
		}
	} while (sitem && sitem.getNext(null,_mode));

	for(var x=0;x<=sizeX-_x;x++)
	{
		for(var y=0;y<=sizeY-_y;y++)
		{
			if (stashspace[x][y]!="empty") 	continue;
			var fail=false;
				findnext:
				for(var j=0;j<_x;j++)
				{
					for(var k=0;k<_y;k++)
					{
						if (stashspace[x+j][y+k]!="empty")
						{
							fail=true;
							break findnext;
						}
					}
				}
			if (!fail)
				return { x:x , y:y };
		}
	}
	return false;
}


function DoShop(englishname, classid, bCancel, bMove)
{
	if ( bMove && !getUIFlag(0x0C) && !getUIFlag(8) ) // no interact no trade
		if ( !Town.MoveTo(englishname,5) )
			return false;

	var npc=getUnit(1,classid);
	if ( !npc ) {
		var retry = 0;
		do {
			DoDel( 500 );
			npc=getUnit(1,classid);
		} while ( !npc && retry++ < 10 );
	};

	if ( !npc ) {
		bprint("*ERROR Unable to find "+englishname);
		return false;
	};

	var timer2=5000;
	while(!getUIFlag(0x0C) && !getUIFlag(8) && timer2 > 0 ) { // no interact, no trade, no time out
		var pos = new coord(me);
		var timer = 5000;
		while(pos.dist(npc) > 3 && timer > 0 ) {
			if (me.mode != 2 && me.mode != 3 && me.mode != 6)
				ClickMap(npc.x, npc.y);
			delay(50);
			timer -= 50;
			pos.set(me);
		}

		if ( timer <= 0 ) {
			bprint("*ERROR Unable to be near "+englishname);
			return false;
		};

		ClickMap(npc);
		delay(500);
		timer2 -= 500;
	};
	if ( timer2 <= 0 ) {
		bprint("*ERROR Unable to interact with "+englishname);
		return false;
	};

	var trade = 0x0D44;
	if ( classid == Sc_MonsterClassID_Charsi || classid == Sc_MonsterClassID_Fara
		|| classid == Sc_MonsterClassID_Hratli || classid == Sc_MonsterClassID_Halbu
		|| classid == Sc_MonsterClassID_Larzuk )
		trade = 0x0D06;

	var timer = 5000;
	while(!getUIFlag(0x0C) && timer > 0 ) {
		npc.useMenu(trade);
		delay(500);
		timer -= 500;
	}

	if ( timer <= 0 ) {
		while(getUIFlag(8)) { // no time here, we need to go out of interact
			me.cancel(1);
			delay(500);
		}
		bprint("*ERROR Unable to begin trade with "+englishname);
		return false;
	};

	var res = DaeBM_ShopIt(npc.name,npc);

	if ( bCancel ) {
		while(getUIFlag(8)) {
			me.cancel(1);
			delay(500);
		};
	};

	return res;
}

function Dae_GenerateMapInventory( mode )
{
	var width = 10;
	var height = 4;
	if ( !mode )
		mode = 100;

	if ( mode == 103 ) {
		width = 3;
		height = 4;
	} else if ( mode == 104 ) {
		width = 6;
		if ( me.gametype )
			height = 8;
		else
			height = 4;
	};

	var inventory = new Array(width);
	for (var i = 0; i < width; i++) {
		inventory[i] = new Array(height);
		for (var j = 0; j < height; j++) {
			inventory[i][j] = 0;
		}
	}

	var item = getUnit(4,null,mode);
	do {
		if (item) {
			var p = item.getParent();
			if (!p || (p && p.name != me.name))
				continue;

			for (var x = 0; x < GetSizeX(item); x++) {
				for (var y = 0; y < GetSizeY(item); y++) {
					inventory[item.x+x][item.y+y] = 1;
				}
			}
		}
	}while(item && item.getNext(null,mode));

	return inventory;
};

function Dae_IsFreeSpot(inventory, sizex, sizey)
{
	var btest = true;
	var isizex = inventory.length;
	var isizey = inventory[0].length;
	for (var x=0;x<=isizex-sizex;x++) {
		for (var y=0;y<=isizey-sizey;y++) {
			btest = true;
			for (var xx=x;xx<x+sizex;xx++) {
				for (var yy=y;yy<y+sizey;yy++) {
					if (xx>=isizex || yy>=isizey || inventory[xx][yy])
						btest = false;
				}
			}
			if (btest) {
				return { x:x , y:y };
			}
		}
	}
	return false;
}

function getPotion(type)
{
	if(!type)
		return null;

	var Pot=getUnit(4,type,100);
	if(Pot) do
	{
		if( Pot.getParent() && Pot.getParent().name == me.name)
			return Pot;
	} while(Pot && Pot.getNext(type,100))

	Pot=getUnit(4,type,2);
	if(Pot) do
	{
		// not optimal but readable !!
		if( Pot.getParent() && Pot.getParent().name == me.name)
			return Pot;
	} while(Pot && Pot.getNext(type,2))
	return null;
}

function HasRejuPot()
{
	if ( getPotion("rvl") || getPotion("rvs") )
		return true;
};

function HasManaPot()
{
	for (var i = 5; i > 0; i--)
		if ( getPotion("mp" + i.toString()) )
			return true;

	return false;
}

function HasLifePot()
{
	for (var i = 5; i > 0; i--)
		if ( getPotion("hp" + i.toString()) )
			return true;

	return false;
}

// 1 => inventory
// 2 => potion
function CheckIfReturnInTown( bcheckinv ,blnBattle)
{
	if (!blnBattle) blnBattle=false;

	if (blnBattle && !sets["back_town_battle"]) return 0;
	if (!blnBattle && !sets["back_town_pathfinding"]) return 0;

	var bReju = HasRejuPot();
	if ( !bReju ) {
		if ( !HasLifePot() ) {
			sets["hpmax"] = me.hpmax;
			var hpthresh = (sets["town_hp_no_pots"]<99)?Math.floor((sets["town_hp_no_pots"] * sets["hpmax"]) / 100):sets["town_hp_no_pots"];
			if ( me.hp < hpthresh ) {
				bprint("no pot life left and low life => town");
				return 2;
			};
		}
		if ( !HasManaPot() ) {
			sets["mpmax"] = me.mpmax;
			var mpthresh = (sets["town_mp_no_pots"]<99)?Math.floor((sets["town_mp_no_pots"] * sets["mpmax"]) / 100):sets["town_mp_no_pots"];
			if ( me.mp < mpthresh ) {
				bprint("no pot mana left and low mana => town");
				return 2;
			};
		}
	};

	if ( bcheckinv && sets["town_min_col_inventory"] ) {
		var inv = Dae_GenerateMapInventory();
		if ( !Dae_IsFreeSpot( inv, sets["town_min_col_inventory"], 4 ) ) {
			bprint("Oups we need place");
			return 1;
		};
	};

	return 0;
}

function GetEnemyCountNear(target, radius)
{
	var count = 0;
	var pos = new coord(target);
	var e = getUnit(1);
	do {
		if (e && e.mode != 12 && ValidEnemy(e) && e.hp > 0) {
			var p = e.getParent();
			if (!p || p.name != me.name) {
				if (pos.dist(e) <= radius)
					count++;

			}
		}
	}while(e && e.getNext());

	return count;
}

function BackToTown(noyps)
{
	var TownSig=1;
	if (noyps) TownSig|=2;
	var monster = FindClosestEnemyNearPos( me.x, me.y );
	if (monster && GetEnemyCountNear(me,5)>5)
	{
		datapos = initgoodpos(Math.min(sets["min_dist"],8),10);
		checkgoodposex( datapos, monster,1 );
	}

	UseTP();
	var tpspot = new coord(me);
	InTown(TownSig);

	if (!Town.MoveTo(tpspot.x, tpspot.y,me.act)) {
		bprint("Failed to move back");
		return false;
	}

	var portal = Town.GetMyPortal();
	if (!portal) {
		bprint("Failed to detect portal");
		return false;
	}

	var pos = new coord(me);
	var timer = 5000;
	while(pos.dist(portal) > 3 && timer > 0 ) {
		if (me.mode != 2 && me.mode != 3 && me.mode != 6)
			ClickMap(portal.x, portal.y);
		delay(50);
		timer -= 50;
		pos.set(me);
	}

	var timer = 5000;
	do {
		ClickMap(portal);
		delay(500);
		timer -= 500;
	}while(Town.InTown() && timer > 0);

	if (timer <= 0) {
		bprint("Failed to take portal back");
		return false;
	}

	return true;
};


// if i have time, normally Dae_GenerateMapInventory &  Dae_IsFreeSpot will be superior
// but this is very easy to check
function DaeBM_CheckSpace( itemX, itemY )
{
	var inv=new Array(10);

	for(var i=0;i<10;i++) {
		inv[i]=new Array(4);
		for(var j=0;j<4;j++)
			inv[i][j]=0;
	};

	var item=getUnit(4,null,100);
	if(item)do {
		if(item.getParent() && item.getParent().name==me.name) {
			for(var i=0;i<GetSizeX(item);i++)
				for(var j=0;j<GetSizeY(item);j++)
					inv[item.x+i][item.y+j]=1;
		}
	}while(item && item.getNext(null,100));

	for(var j=0;j<5-itemY;j++) {
		invloop2: for(var i=0;i<11-itemX;i++) {
			for(var x=0;x<itemX;x++)
				for(var y=0;y<itemY;y++)
					if(inv[i+x][j+y])
						continue invloop2;
			return true;
		}
	}

	return false;
}

function DaeBM_ShopIt(who,npc)
{
	var checkprint=0;
	var shopdesc="";
	var goldprev=0;
	var itemsBought=new Array();
	var itemName="";
	log["ShopTimes"]++;
	LogSave(0);
	var shopitem = getUnit(4,null,0);
	if (shopitem) do
	{
		var owner = shopitem.getParent();
		if (owner) if (owner.name==who)
		{
			if (logging >= 1)
				shopdesc=shopitem.fname;
			if (logging >= 2)
				shopdesc+=getAllStats(shopitem);

			if(checkprint == 0)
			{
				//print("Shopping at: " +who);
				checkprint++;
			}

			if (CheckItem(shopitem, ShopItINIfile))
			{
				writedesc=shopdesc;
				itemName=shopitem.fname;
				// check if enough room
				if ( DaeBM_CheckSpace( GetSizeX(shopitem),GetSizeX(shopitem)) ) {
					goldprev=me.getStat(14)+me.getStat(15);
					if(goldprev<shopitem.getItemCost(0))
					{
						itemsBought.push([itemName,"not enough gold ("+goldprev+"/"+shopitem.getItemCost(0)+")"]);
						Slog(shopitem,"buygold");
					}
					else
					{
						delay(500);
						var retry = 0;
						do {
					  		shopitem.shop(npc,2);
					  		DoDel(1000);
						}while( ( goldprev == (me.getStat(14) + me.getStat(15)) ) && ( retry++ < 10 ) );
						if(goldprev!=me.getStat(14)+me.getStat(15))
							itemsBought.push([itemName,"success"]);
						else {
							itemsBought.push([itemName,"not enough gold"]);
							Slog(shopitem,"buyweird");
							return itemsBought;
						};
					}
				}
				else {
					itemsBought.push([itemName,"not enough space"]);
					Slog(shopitem,"buyspace");
					return itemsBought;
				};
				print("Just bought " +writedesc+"ÿc  on "+STime());
				HtmlLogFile("buy");
			}
			if (logging >= 3)
			{
				writedesc=shopdesc;
				HtmlLogFile("none");
			}
		}
		shopitem.fname="";														// wtf?
	} while(shopitem && shopitem.getNext(null,0));
	if(checkprint == 0) print("Shopping at " +who +" failed!");

	return itemsBought;
	//return sthShopped; //1.60a
}

function GoGamble()
{
	var gamblenpc=new Array();
	gamblenpc[0]="gheed";
	gamblenpc[1]="elzix";
	gamblenpc[2]="alkor";
	gamblenpc[3]="jamella";
	gamblenpc[4]="anya";

	Town.MoveTo(gamblenpc[me.act-1],me.act);

	npc=getUnit(1,gamblenpc[me.act-1]);
	if (!npc) return false;
	walkto(npc.x,npc.y);
	delay(500);

	var retries=0;
	while(!getUIFlag(0x08) && retries++<5)
	{
		ClickMap(npc);
		delay(500);
	}
	if (!getUIFlag(0x08)) return false;

	var retries=0;
	while(!getUIFlag(0x0C) && retries++<5)
	{
		npc.useMenu(0x0D46);
		delay(500);
	}
	if (!getUIFlag(0x0C)) return false;

	return npc;
}

function GambleIt(who,npc)
{
	var checkprint=0;
	var shopdesc="";
	var goldprev=0;
	var itemsBought=new Array();
	var itemName="";
	var itemlist=new Array();
	var itemb=0;
	var tries=0;
	var finditem=true;
	while(tries++<20 && finditem)
	{
		finditem=false;
		var shopitem = getUnit(4,null,0);
		if (shopitem) do
		{
			var owner = shopitem.getParent();
			if (owner) if (owner.name==npc.name)
			{
				if(checkprint == 0)
				{
					//print("Shopping at: " +who);
					checkprint++;
				}

				if (shopitem && (shopitem.code=="amu" || shopitem.code=="rin" || getBaseStat(0,shopitem.classid,56) == 15 || getBaseStat(0,shopitem.classid,56) == 16 || getBaseStat(0,shopitem.classid,56)==75))
				{
					if (getBaseStat(0,shopitem.classid,56)==15)
						if (!sets["gamble_boots"]) continue;
					if (getBaseStat(0,shopitem.classid,56)==16)
						if (!sets["gamble_gloves"]) continue;
					if (getBaseStat(0,shopitem.classid,56)==75)
						if (!sets["gamble_circlet"]) continue;
					if (shopitem.code=="rin")
						if (!sets["gamble_ring"]) continue;
					if (shopitem.code=="amu")
						if (!sets["gamble_amulet"]) continue;

					finditem=true;

					// check if enough room
					if ( DaeBM_CheckSpace( GetSizeX(shopitem),GetSizeX(shopitem) ) ) {
						goldprev=me.getStat(14)+me.getStat(15);
						if(goldprev<getBaseStat(0,shopitem.classid,D2JSP_BASE_ITEMS_GAMBLE_COST))
						{
							//itemsBought.push([itemName,"not enough gold ("+goldprev+"/"+shopitem.getItemCost(0)+")"]);
							Slog(shopitem,"buygold");
						}
						else
						{
							delay(500);
							var retry = 0;
							do {
						  		shopitem.shop(npc,2);
						  		var shopitem_gid=shopitem.gid;
						  		DoDel(1000);
							}while( ( goldprev == (me.getStat(14) + me.getStat(15)) ) && ( retry++ < 10 ) );
							if(goldprev!=me.getStat(14)+me.getStat(15))
							{
								goldprev = me.getStat(14)+me.getStat(15);
								var itemcode=shopitem.code;

								buyitem=getUnit(4,itemcode,100);
								if (buyitem) do
								{
									if (buyitem.gid!=shopitem.gid) continue;
									if (!CheckItem(buyitem,sets["gamble_ini"]))
									{
										//itemBought.push([itemName,"no good"]);
										bprint("Not good,sell back");
						  				if (!SellItem(npc,buyitem)) 
						  				{
						  					DoDel(500);
						  					if (!SellItem(npc,buyitem)) return false;
						  				}
									}
									else
									{
										if (logging >= 1)
											shopdesc=shopitem.fname;
										if (logging >= 2)
											shopdesc+=getAllStats(shopitem);
										writedesc=shopdesc;
										itemName=shopitem.fname;

										itemlist[itemb++]=buyitem.gid;
									}
								}while(buyitem && buyitem.getNext(itemcode,100));
							}
							else {
								//itemsBought.push([itemName,"not enough gold"]);
								//Slog(shopitem,"buyweird");
								return false;
							};
						}
					}
					else {
						//itemsBought.push([itemName,"not enough space"]);
						//Slog(shopitem,"buyspace");
						return false;
					};
					if (writedesc)
					{
						print("Just bought " +writedesc+"ÿc  on "+STime());
						HtmlLogFile("buy");
					}
				}
				if (logging >= 3)
				{
					writedesc=shopdesc;
					HtmlLogFile("none");
				}
			}
			//shopitem.fname="";														// wtf?
		} while(shopitem && shopitem.getNext(null,0) && !finditem);
	}
	if(checkprint == 0) print("Gamble at " +who +" failed!");

	var retries=0;
	while(retries++<5 && getUIFlag(0x08))
	{
		me.cancel(1);
		//npc.cancel(1);
		delay(500);
	}
	if (getUIFlag(0x08)) me.cancel(1);

	if (!itemlist) var itemlist=true;
	return itemlist;
	//return sthShopped; //1.60a
}


function CheckQuest()
{

    if (!getWaypoint(2))
    {
    	if (listboss[16].quest)
        {
        	bprint("You don't have waypoint to ÿc2Stony field,ÿc@cancel Questÿc2 " + listboss[16].name);
            listboss[16].quest=false;
        }
    }
	if (!getWaypoint(4))
	{
		if (listboss[10].quest)
		{
			bprint("You don't have waypoint to ÿc2Black Marsh,ÿc@cancel Questÿc2 " + listboss[10].name);
			listboss[10].quest=false;
		}
	}
	if (!getWaypoint(22))
	{
		if (listboss[12].quest)
		{
			bprint("You don't have waypoint to ÿc2Lower Kurust,ÿc@cancel Questÿc2 " + listboss[12].name);
			listboss[12].quest=false;
		}
	}
	if (!getWaypoint(26))
	{
		if (listboss[11].quest) bprint("You don't have waypoint to ÿc2Durance of Hate Level 2,ÿc@cancel Questÿc2 " + listboss[11].name);
		{
			listboss[11].quest=false;
		}
	}
	if (!getWaypoint(31))
	{
		if (listboss[3].quest)
		{
			bprint("You don't have waypoint to ÿc2Frigid Highlands,ÿc@cancel Questÿc2 " + listboss[3].name);
			listboss[3].quest=false;
		}
		if (listboss[4].quest)
		{
			bprint("You don't have waypoint to ÿc2Frigid Highlands,ÿc@cancel Questÿc2 " + listboss[4].name);
			listboss[4].quest=false;
		}
		if (listboss[5].quest)
		{
			bprint("You don't have waypoint to ÿc2Frigid Highlands,ÿc@cancel Questÿc2 " + listboss[5].name);
			listboss[5].quest=false;
		}
		if (listboss[6].quest)
				{
			bprint("You don't have waypoint to ÿc2Frigid Highlands,ÿc@cancel Questÿc2 " + listboss[6].name);
			listboss[6].quest=false;
		}
	}
	if (!getWaypoint(32))
	{
		if (listboss[1].quest)
		{
			bprint("You don't have waypoint to ÿc2Arreat Plateau,ÿc@cancel Questÿc2 " + listboss[1].name);
			listboss[1].quest=false;
		}
		if (listboss[2].quest)
		{
			bprint("You don't have waypoint to ÿc2Arreat Plateau,ÿc@cancel Questÿc2 " + listboss[2].name);
			listboss[2].quest=false;
		}
	}
	if (!getWaypoint(33))
	{
		if (listboss[9].quest)
		{
			bprint("You don't have waypoint to ÿc2Crystalline Passage,ÿc@cancel Questÿc2 " + listboss[9].name);
			listboss[9].quest=false;
		}
	}
	if (!getWaypoint(34))
	{
		if (listboss[8].quest)
		{
			bprint("You don't have waypoint to ÿc2Glacial Trail,ÿc@cancel Questÿc2 " + listboss[8].name);
			listboss[8].quest=false;
		}
	}
	if (!getWaypoint(37))
	{
		if (listboss[7].quest)
		{
			bprint("You don't have waypoint to ÿc2The Ancients' Way,ÿc@cancel Questÿc2 " + listboss[7].name);
			listboss[7].quest=false;
		}
	}
	if (!getWaypoint(35) && sets["use_wp_nihlathak"])
	{
		if (listboss[14].quest)
		{
			bprint("You don't have waypoint to ÿc2Halls of Pain,ÿc@cancel Questÿc2 " + listboss[14].name);
			listboss[14].quest=false;
		}
	}
	if (!getWaypoint(38))
	{
		if (listboss[13].quest)
		{
			bprint("You don't have waypoint to ÿc2Worldstone Keep Level 2,ÿc@cancel Questÿc2 " + listboss[13].name);
			listboss[15].quest=false;
		}
	}

	if (getBossCount()==0 && sets["prevent_no_boss"])
	{
		if (!sets["random_boss_list"].length)
		{
			listboss[0].quest=true;
			DoBoss(bosspindle.GotoBoss,bosspindle);
		}
		else
		{
			var n = rnd(0,sets["random_boss_list"].length-1);
			var n2 = sets["random_boss_list"][n]-1;
			listboss[n2].quest=true;
			bprint("You disabled all bosses!Bot randomly chose ÿc2" + listboss[n2].name + "ÿc@ for target!");
			DoBoss(listboss[n2].GotoBoss,listboss[n2]);
		}
		return true;
	}


}

function BuyAntidote()
{
	if (!sets["use_special_pot"]) return false;
	bprint("Going to buy Antidote pot");
	Town.MoveTo("malah",5);
	Town.Heal(Antidote,false);
}

function Antidote()
{
	npc=getUnit(1,"malah");
	if (!npc) return;

	for(i=0;i<sets["buy_antidote_baal"][1];i++)
	{
		BuyItem(npc,"yps",false);
		DoDel(50);
	}

	npc.cancel();
	me.cancel(0);
}

function DoDelEx(_Amount)
{
	//Advence function of DoDel function,used in version 0.48.

	var _lagmode=(me.ping>500);
	var _Plus=1+(rnd(1,5)/10);
	var _Plus2=Math.abs(_Amount+me.ping)/2;
	var _Plus3=(me.ping/2)>200?250:me.ping/2;

	if (_lagmode)
		delayvalue=parseInt(_Amount+rnd(50,100)+(me.ping/_Plus)+_Plus2);
	else
		delayvalue=parseInt(_Amount+rnd(10,50)+_Plus3);
	if (delayvalue<0) delayvalue=10;

	delay(delayvalue);
}

function LoadSettings() //0.47c+ moved here.
{
	var f = fileOpen("libs/Dae/Perso/"+me.name+".d2l",0);
	
	if (f && !included) {
		f.close(); //permit editing the file while the bot is running
		f = null;
		print("ÿc3:: ...loading Dae/Perso/"+me.name+".d2l");
		include("Dae/Perso/"+me.name+".d2l");
		if (typeof(SettingVersion)=="undefined")
		{
			print("ÿc1:: Your personal setting file doesn't match current version,load default settings.");
			include("Dae_Multi_Set.d2l");
		}
		else
		{
			if (SettingVersion!=REQUIRED_SETTING_VERSION)
			{
				print("ÿc1:: Your personal setting file doesn't match current version,load default settings.");
				include("Dae_Multi_Set.d2l");
			}
		}
		included=true;
	} else {
		//print("ÿc3:: no Dae/Perso/"+me.name+".d2l detected (this is not an error)");
		include("Dae_Multi_Set.d2l");
	};
	if (typeof(SettingVersion)=="undefined")
		print("ÿc1:: All settings file don't match current bot,use at your own risk!");
	else{
		if(SettingVersion!=REQUIRED_SETTING_VERSION)
				print("ÿc1:: All settings file don't match current bot,use at your own risk!");
	}
}

function LoadDictionary()
{
	var gamename="";
	var gamepass="";

	var useDDE=false;
	var f = fileOpen("libs/d2jspLoader.d2l",0);
	if (!f)
	{
		bprint("Please copy your d2jspLoader.d2l to your libs directory!");
		useDDE=true;
	}
	else
		f.close();

	if (!sets["use_custom_name_pass"]) return false;

	do
	{
		if (sets["gamename_mode"]==1)
		{
			var f=fileOpen(sets["gamename_dict"],0);
			if (!f)
			{
				bprint("You don't have a gamename dictionary or your path is incorrect!");
				return false;
			}
			var linecount=GetLineCount(f);
			var linenum=rnd(0,linecount-1);
			if (log["DictNumber"]>=linecount) log["DictNumber"]=0;

			if (linecount=0) return false;
			if (sets["gamename_dict_mode"]==2) linenum=log["DictNumber"]+1;

			f.close(); //reopen

			var f=fileOpen(sets["gamename_dict"],0);
			if (!f) 
				return false;
			for(i=0;i<linenum;i++)
			{
				var line=f.readLine();
				if (line.slice(0,1)==";" || line.slice(0,2)=="//" || line=="")
				{
					i--;
					continue;
				}
			}
			gamename=line;

			f.close();
		}
		else if (sets["gamename_mode"]==2)
		{
			var rndnum=rnd(sets["gamename_randomly"][0],sets["gamename_randomly"][1]);

			var charArr=sets["gamename_keys"].split(",");
			if (!charArr || !charArr.length) return false;

			for(var i=0;i<rndnum;i++)
			{
				var intrnd=rnd(1,charArr.length)-1;
				gamename+=charArr[intrnd];
			}
		}
		delay(300);
	}while(gamename == log["GameName"]);

	if (sets["gamepass_mode"]==1)
		gamepass=sets["gamepass_fixed"];
	else
	{
		var rndnum=rnd(sets["gamepass_randomly"][0],sets["gamepass_randomly"][1]);

		var charArr=sets["gamepass_keys"].split(",");
		if (!charArr || !charArr.length) return false;

		for(var i=0;i<rndnum;i++)
		{
			var intrnd=rnd(1,charArr.length)-1;
			gamepass+=charArr[intrnd];
		}
	}

	if (!gamename) return false;

	if (useDDE)
	{
		var msg = prepareMsg(false);
    		msg+="onexit ";
    		msg+="create ";
           	msg+=gamename;
           	if (gamepass) msg+="/" + gamepass;
           	sendDDE(2, "d2jspLoader", msg, "", "");
         }
         else
         	guiOnExit("create",gamename,gamepass);

        log["GameName"]=gamename;
        log["DictNumber"]++;
        LogSave(0);
        bprint("I've created a gamename and a password for the next game!");

}

function prepareMsg(nopid)
{
   if (nopid) return "0 ";
   return getMyPID() + " ";
}

function GetLineCount(_file)
{
	var count=0;

	if (!_file) return 0;
	while(!_file.eof)
	{
		var line=_file.readLine();
		count++;
	}
	return count;
}

function CleanUpMe(radius)
{
    if (!radius) radius=20;
    var nennemies = 0;
    var monster;
    var sthkilled = false;

    do {
              monster = FindEnemyNear( me, radius );
              if ( monster ) {
                 if (CheckMonster(monster)==2){
                 	sthkilled = KillNormalBoss(monster);
                 }
                 else
                 	sthkilled = KillMonster( monster, 30 );
                 nennemies++;
             };
        } while ( monster && ( nennemies < 5 ) );

    if ( sthkilled )
        Pick();
}

function ValidEnemy(enemy)
{
	if (!enemy) {
		DebugWrite("*WARNING ValidEnemy() : no enemy");
		return false;
	}
	if (!enemy.name.length) {
		return false;
	}

	if (enemy.area == 1 || enemy.area == 40 || enemy.area == 75 || enemy.area == 103 || enemy.area == 109) { return false; }

	switch(enemy.name) {
		case "Combatant":	// a5 bloodyhills barb
		case "an evil force":
		case "Dummy":
		case "Hadriel":		// a4 near river of flame
		case "Flavie":		// a1 nead cold plains
		case "Catapult":	// a5 invisible catapults?
		case "Hydra":
			return false;
	}

	return true;
}

function GetSizeX(item)
{
	return getBaseStat(0,item.classid,D2JSP_BASE_ITEMS_INVWIDTH);
}

function GetSizeY(item)
{
	return getBaseStat(0,item.classid,D2JSP_BASE_ITEMS_INVHEIGHT);
}

//taken from Darien's Level bot
function getFarUnitXY (type,IDnumb) {
	if (cMap.AreaInitialized != me.area) {
		bprint("Reinitializing Map...");
		cMap.InitializeMap();
	}
	for (var p = 0; p < cMap.PresetUnits.length; p++) {
		if(cMap.PresetUnits[p].type == type && 
		cMap.PresetUnits[p].id == IDnumb) {
			break;
		}
	}
	
	return cMap.PresetUnits[p];
}

function gamemsgHandler(msg)
{
	if (!sets["log_whispers"]) return;
	var Message=new Object();
	Message.Msg=msg;

	if (Message.Msg.indexOf("From")==0)
	{
		Message.Quote_Position=Message.Msg.indexOf(":");
		Message.WhisperFrom=Message.Msg.substr(4,Message.Quote_Position-4);
		Message.Left_Bracket=Message.Msg.indexOf("(") 
		Message.Right_Bracket=Message.Msg.indexOf(")");
		Message.Account=Message.Msg.substr(Message.Left_Bracket+2,Message.Right_Bracket-Message.Left_Bracket-2);
		Message.Character=Message.WhisperFrom.substr(0,Message.Left_Bracket-4);
		Message.Message=Message.Msg.substr(Message.Quote_Position+1,-1);
		//in future versions,a reply tools may be added here.
		
		var d=new Date();
		var f=fileOpen("output/Dae_"+me.name+"_MsgLog.txt",2);
		if (f)
		{
			f.writeLine("["+d.toLocaleString()+"] " + Message.Msg);
			f.close();
		}
	}

}
